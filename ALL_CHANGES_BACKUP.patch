diff --git a/src/auto_fix_encoding.py b/src/auto_fix_encoding.py
deleted file mode 100644
index 02f8a04..0000000
--- a/src/auto_fix_encoding.py
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/usr/bin/env python3
-import os
-import sys
-from pathlib import Path
-
-TEXT_EXTENSIONS = {
-    ".c", ".cpp", ".h", ".hpp", ".inl",
-    ".py", ".cmake", ".txt", ".md",
-    ".json", ".yml", ".yaml",
-    ".sh", ".bat"
-}
-
-def is_probably_text(path: Path) -> bool:
-    return path.suffix.lower() in TEXT_EXTENSIONS
-
-def fix_file(path: Path):
-    try:
-        raw = path.read_bytes()
-    except Exception:
-        return
-
-    if b"\x00" in raw[:1024] and path.suffix.lower() not in TEXT_EXTENSIONS:
-        return
-
-    encodings = ["utf-8", "utf-16", "utf-16-le", "utf-16-be", "utf-32"]
-
-    text = None
-    used_encoding = None
-
-    for enc in encodings:
-        try:
-            text = raw.decode(enc)
-            used_encoding = enc
-            break
-        except UnicodeDecodeError:
-            continue
-
-    if text is None:
-        return
-
-    cleaned = text.replace("\x00", "")
-
-    if used_encoding != "utf-8" or cleaned != text:
-        path.write_text(cleaned, encoding="utf-8", newline="\n")
-        print(f"[FIXED] {path} ({used_encoding} → utf-8)")
-
-def walk(root: Path):
-    for p in root.rglob("*"):
-        if p.is_file() and is_probably_text(p):
-            fix_file(p)
-
-if __name__ == "__main__":
-    root = Path(sys.argv[1]) if len(sys.argv) > 1 else Path(".")
-    print(f"Scanning: {root.resolve()}")
-    walk(root)
-    print("Done.")
diff --git a/src/command/command_base.hpp b/src/command/command_base.hpp
index 41b83a4..dd128f9 100644
--- a/src/command/command_base.hpp
+++ b/src/command/command_base.hpp
@@ -1,11 +1,15 @@
-#pragma once
+﻿#pragma once
 
-#include "command_context.hpp"
 #include "permission.hpp"
 
 #include <string>
 #include <vector>
 
+namespace cyrex::command
+{
+
+struct CommandContext;
+
 class CommandBase
 {
 public:
@@ -17,8 +21,8 @@ public:
         return {};
     }
     virtual std::string description() const = 0;
-
     virtual Permission permission() const = 0;
 
-    virtual void execute(const CommandContext& ctx) = 0;
+    virtual void execute(CommandContext& ctx) = 0;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/command_context.hpp b/src/command/command_context.hpp
index c270ee7..94634d6 100644
--- a/src/command/command_context.hpp
+++ b/src/command/command_context.hpp
@@ -5,13 +5,19 @@
 #include <string>
 #include <vector>
 
+namespace cyrex
+{
 class Server;
+}
+
+namespace cyrex::command
+{
 
 struct CommandContext
 {
-    Server& server;
+    cyrex::Server& server;
     std::string raw;
     std::vector<std::string> args;
-
     PermissionLevel sourceLevel;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/command_manager.cpp b/src/command/command_manager.cpp
index c9dedec..69aba63 100644
--- a/src/command/command_manager.cpp
+++ b/src/command/command_manager.cpp
@@ -1,34 +1,35 @@
-#include "command_context.hpp"
 #include "command_manager.hpp"
+
 #include "command/types/performance_command.hpp"
 #include "command/types/stop_command.hpp"
+#include "command_context.hpp"
 #include "server.hpp"
 #include "util/textformat.hpp"
 
 #include <iostream>
 #include <sstream>
 
-CommandManager::CommandManager(Server& server) : m_server(server)
+cyrex::command::CommandManager::CommandManager(cyrex::Server& server) : m_server(server)
 {
 }
 
-void CommandManager::registerDefaults()
+void cyrex::command::CommandManager::registerDefaults()
 {
-    registerCommand(std::make_unique<StopCommand>());
-    registerCommand(std::make_unique<PerformanceCommand>());
+    registerCommand(std::make_unique<cyrex::command::types::StopCommand>());
+    registerCommand(std::make_unique<cyrex::command::types::PerformanceCommand>());
 }
 
-void CommandManager::registerCommand(std::unique_ptr<CommandBase> command)
+void cyrex::command::CommandManager::registerCommand(std::unique_ptr<CommandBase> command)
 {
     m_registry.registerCommand(std::move(command));
 }
 
-bool CommandManager::hasPermission(PermissionLevel source, const Permission& required) const
+bool cyrex::command::CommandManager::hasPermission(PermissionLevel source, const Permission& required) const
 {
     return static_cast<int>(source) >= static_cast<int>(required.level);
 }
 
-void CommandManager::executeConsole(const std::string& line)
+void cyrex::command::CommandManager::executeConsole(const std::string& line)
 {
     std::istringstream ss(line);
     std::string name;
@@ -45,10 +46,11 @@ void CommandManager::executeConsole(const std::string& line)
     auto* cmd = m_registry.find(name);
     if (!cmd)
     {
-        std::cout << util::textformat::renderConsole(
-                         util::textformat::bedrock(util::textformat::Color::RED) +
-                         util::textformat::bedrock(util::textformat::Style::BOLD) + "[Cyrex] The command you have entered does not exist, make sure the spelling is correct." +
-                         util::textformat::bedrock(util::textformat::Style::RESET), false)
+        std::cout << cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::RED) +
+                                                    cyrex::util::bedrock(cyrex::util::Style::BOLD) +
+                                                    "[Cyrex] The command you have entered does not exist." +
+                                                    cyrex::util::bedrock(cyrex::util::Style::RESET),
+                                                false)
                   << std::endl;
         return;
     }
@@ -57,15 +59,15 @@ void CommandManager::executeConsole(const std::string& line)
 
     if (!hasPermission(sourceLevel, cmd->permission()))
     {
-        std::cout << util::textformat::renderConsole(
-                         util::textformat::bedrock(util::textformat::Color::GOLD) +
-                         util::textformat::bedrock(util::textformat::Style::BOLD) + "[Cyrex] You do not have permission to use this command." +
-                         util::textformat::bedrock(util::textformat::Style::RESET), false)
+        std::cout << cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::GOLD) +
+                                                    cyrex::util::bedrock(cyrex::util::Style::BOLD) +
+                                                    "[Cyrex] You do not have permission to use this command." +
+                                                    cyrex::util::bedrock(cyrex::util::Style::RESET),
+                                                false)
                   << std::endl;
         return;
     }
 
     CommandContext ctx{m_server, line, args, sourceLevel};
-
     cmd->execute(ctx);
 }
diff --git a/src/command/command_manager.hpp b/src/command/command_manager.hpp
index 2c9aafe..422f2f9 100644
--- a/src/command/command_manager.hpp
+++ b/src/command/command_manager.hpp
@@ -1,25 +1,33 @@
 #pragma once
 
+#include "command_base.hpp"
 #include "command_registry.hpp"
 #include "permission.hpp"
 
+#include <memory>
 #include <string>
 
+namespace cyrex
+{
 class Server;
+}
+
+namespace cyrex::command
+{
 
 class CommandManager
 {
 public:
-    explicit CommandManager(Server& server);
+    explicit CommandManager(cyrex::Server& server);
 
     void registerDefaults();
     void registerCommand(std::unique_ptr<CommandBase> command);
-
     void executeConsole(const std::string& line);
 
 private:
-    bool hasPermission(PermissionLevel source, const Permission& required) const;
+    bool hasPermission(PermissionLevel source, const cyrex::command::Permission& required) const;
 
-    Server& m_server;
+    cyrex::Server& m_server;
     CommandRegistry m_registry;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/command_registry.cpp b/src/command/command_registry.cpp
index 924fda4..5d994f0 100644
--- a/src/command/command_registry.cpp
+++ b/src/command/command_registry.cpp
@@ -1,6 +1,8 @@
 #include "command_registry.hpp"
 
-void CommandRegistry::registerCommand(std::unique_ptr<CommandBase> command)
+#include "command_base.hpp"
+
+void cyrex::command::CommandRegistry::registerCommand(std::unique_ptr<CommandBase> command)
 {
     CommandBase* ptr = command.get();
 
@@ -11,10 +13,8 @@ void CommandRegistry::registerCommand(std::unique_ptr<CommandBase> command)
     m_storage.push_back(std::move(command));
 }
 
-CommandBase* CommandRegistry::find(const std::string& name) const
+cyrex::command::CommandBase* cyrex::command::CommandRegistry::find(const std::string& name) const
 {
     auto it = m_lookup.find(name);
-    if (it == m_lookup.end())
-        return nullptr;
-    return it->second;
+    return it == m_lookup.end() ? nullptr : it->second;
 }
diff --git a/src/command/command_registry.hpp b/src/command/command_registry.hpp
index bb7870c..c73bd68 100644
--- a/src/command/command_registry.hpp
+++ b/src/command/command_registry.hpp
@@ -1,10 +1,14 @@
 #pragma once
 
-#include "command_base.hpp"
-
 #include <memory>
 #include <string>
 #include <unordered_map>
+#include <vector>
+
+namespace cyrex::command
+{
+
+class CommandBase;
 
 class CommandRegistry
 {
@@ -16,3 +20,4 @@ private:
     std::unordered_map<std::string, CommandBase*> m_lookup;
     std::vector<std::unique_ptr<CommandBase>> m_storage;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/permission.hpp b/src/command/permission.hpp
index de9058f..a333231 100644
--- a/src/command/permission.hpp
+++ b/src/command/permission.hpp
@@ -2,8 +2,11 @@
 
 #include <string>
 
+namespace cyrex::command {
+
 enum class PermissionLevel
 {
+    // more required as future goes on..
     PLAYER = 0,
     OP = 1,
     CONSOLE = 2
@@ -14,3 +17,4 @@ struct Permission
     std::string node;
     PermissionLevel level;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/types/performance_command.cpp b/src/command/types/performance_command.cpp
index d6ca804..87c8ad3 100644
--- a/src/command/types/performance_command.cpp
+++ b/src/command/types/performance_command.cpp
@@ -1,27 +1,28 @@
 #include "performance_command.hpp"
+
+#include "command/permission.hpp"
+
 #include "util/performance.hpp"
 #include "util/textformat.hpp"
-#include "command/permission.hpp"
 
 #include <iostream>
 
-std::string PerformanceCommand::name() const
+std::string cyrex::command::types::PerformanceCommand::name() const
 {
     return "performance";
 }
 
-std::string PerformanceCommand::description() const
+std::string cyrex::command::types::PerformanceCommand::description() const
 {
     return "Shows server performance stats";
 }
 
-Permission PerformanceCommand::permission() const
+cyrex::command::Permission cyrex::command::types::PerformanceCommand::permission() const
 {
     return {"server.performance", PermissionLevel::OP};
 }
 
-void PerformanceCommand::execute(const CommandContext&)
+void cyrex::command::types::PerformanceCommand::execute(CommandContext&)
 {
-    // TODO: make it so we can see if it was send by console or in-game
-    std::cout << util::textformat::renderConsole(util::performance::getReport(), false) << std::endl;
+    std::cout << cyrex::util::renderConsole(cyrex::util::getReport(), false) << std::endl;
 }
diff --git a/src/command/types/performance_command.hpp b/src/command/types/performance_command.hpp
index b4f538e..b13b52f 100644
--- a/src/command/types/performance_command.hpp
+++ b/src/command/types/performance_command.hpp
@@ -1,13 +1,15 @@
 #pragma once
 
 #include "command/command_base.hpp"
-#include "command/command_context.hpp"
 
+namespace cyrex::command::types
+{
 class PerformanceCommand final : public CommandBase
 {
 public:
     std::string name() const override;
     std::string description() const override;
     Permission permission() const override;
-    void execute(const CommandContext& ctx) override;
+    void execute(CommandContext& ctx) override;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/command/types/stop_command.cpp b/src/command/types/stop_command.cpp
index 0b4f440..928a669 100644
--- a/src/command/types/stop_command.cpp
+++ b/src/command/types/stop_command.cpp
@@ -1,28 +1,30 @@
 #include "stop_command.hpp"
+
+#include "command/permission.hpp"
+#include "command/command_context.hpp"
 #include "server.hpp"
 
-std::string StopCommand::name() const
+std::string cyrex::command::types::StopCommand::name() const
 {
     return "stop";
 }
 
-std::vector<std::string> StopCommand::aliases() const
+std::vector<std::string> cyrex::command::types::StopCommand::aliases() const
 {
     return {"shutdown", "exit"};
 }
 
-std::string StopCommand::description() const
+std::string cyrex::command::types::StopCommand::description() const
 {
     return "Stops the server";
 }
 
-Permission StopCommand::permission() const
+cyrex::command::Permission cyrex::command::types::StopCommand::permission() const
 {
     return {"server.stop", PermissionLevel::CONSOLE};
 }
 
-void StopCommand::execute(const CommandContext& ctx)
+void cyrex::command::types::StopCommand::execute(CommandContext& ctx)
 {
-    // why does lapinozz want to use this instead of a dedicated function? i mean okay wont question, just let it be lmao
-    ctx.server.~Server();
+    ctx.server.stop();
 }
diff --git a/src/command/types/stop_command.hpp b/src/command/types/stop_command.hpp
index 519dbe5..e3d34a8 100644
--- a/src/command/types/stop_command.hpp
+++ b/src/command/types/stop_command.hpp
@@ -2,6 +2,8 @@
 
 #include "command/command_base.hpp"
 
+namespace cyrex::command::types
+{
 class StopCommand final : public CommandBase
 {
 public:
@@ -9,5 +11,6 @@ public:
     std::vector<std::string> aliases() const override;
     std::string description() const override;
     Permission permission() const override;
-    void execute(const CommandContext& ctx) override;
+    void execute(CommandContext& ctx) override;
 };
+} // namespace cyrex::command
\ No newline at end of file
diff --git a/src/math/vector2.hpp b/src/math/vector2.hpp
index c0ee9d3..60b0082 100644
--- a/src/math/vector2.hpp
+++ b/src/math/vector2.hpp
@@ -3,6 +3,8 @@
 #include <cmath>
 #include <cstdint>
 
+namespace cyrex::math
+{
 struct Vector2
 {
     float x;
@@ -130,3 +132,4 @@ struct Vector2
         return !(*this == o);
     }
 };
+} // namespace cyrex::math
\ No newline at end of file
diff --git a/src/math/vector3.hpp b/src/math/vector3.hpp
index c6075ad..a058ffc 100644
--- a/src/math/vector3.hpp
+++ b/src/math/vector3.hpp
@@ -3,6 +3,8 @@
 #include <cmath>
 #include <cstdint>
 
+namespace cyrex::math
+{
 struct Vector3
 {
     float x;
@@ -153,3 +155,4 @@ struct Vector3
         return !(*this == o);
     }
 };
+} // namespace cyrex::math
\ No newline at end of file
diff --git a/src/network/mcbe/compression/compressor.hpp b/src/network/mcbe/compression/compressor.hpp
index 12bd04f..4c1216a 100644
--- a/src/network/mcbe/compression/compressor.hpp
+++ b/src/network/mcbe/compression/compressor.hpp
@@ -8,6 +8,9 @@
 #include <cstddef>
 #include <cstdint>
 
+namespace cyrex::network::mcbe::compression
+{
+
 class Compressor
 {
 public:
@@ -15,6 +18,7 @@ public:
 
     virtual bool decompress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) = 0;
     virtual bool compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) = 0;
-    virtual mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept = 0;
+    virtual cyrex::mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept = 0;
     virtual std::optional<size_t> compressionThreshold() const noexcept = 0;
 };
+} // namespace cyrex::network::mcbe::compression
\ No newline at end of file
diff --git a/src/network/mcbe/compression/noop_compressor.hpp b/src/network/mcbe/compression/noop_compressor.hpp
index 362a76c..fa91ce9 100644
--- a/src/network/mcbe/compression/noop_compressor.hpp
+++ b/src/network/mcbe/compression/noop_compressor.hpp
@@ -2,6 +2,9 @@
 
 #include "compressor.hpp"
 
+namespace cyrex::network::mcbe::compression
+{
+
 class NoopCompressor final : public Compressor
 {
 public:
@@ -17,9 +20,9 @@ public:
         return true;
     }
 
-    mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override
+    cyrex::mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override
     {
-        return mcpe::protocol::types::CompressionAlgorithm::NONE;
+        return cyrex::mcpe::protocol::types::CompressionAlgorithm::NONE;
     }
 
     std::optional<size_t> compressionThreshold() const noexcept override
@@ -27,3 +30,4 @@ public:
         return std::nullopt;
     }
 };
+} // namespace cyrex::network::mcbe::compression
\ No newline at end of file
diff --git a/src/network/mcbe/compression/zlib_compressor.cpp b/src/network/mcbe/compression/zlib_compressor.cpp
index d20885a..2fbfb0a 100644
--- a/src/network/mcbe/compression/zlib_compressor.cpp
+++ b/src/network/mcbe/compression/zlib_compressor.cpp
@@ -2,6 +2,9 @@
 
 #include <stdexcept>
 
+namespace cyrex::network::mcbe::compression
+{
+
 ZlibCompressor::ZlibCompressor(int level, std::optional<size_t> minSize, size_t maxDecompressionSize) :
     m_level(level),
     m_minCompressionSize(minSize),
@@ -56,12 +59,13 @@ bool ZlibCompressor::decompress(const uint8_t* input, size_t inputSize, std::vec
     return true;
 }
 
-mcpe::protocol::types::CompressionAlgorithm ZlibCompressor::networkId() const noexcept
+cyrex::mcpe::protocol::types::CompressionAlgorithm ZlibCompressor::networkId() const noexcept
 {
-    return mcpe::protocol::types::CompressionAlgorithm::ZLIB;
+    return cyrex::mcpe::protocol::types::CompressionAlgorithm::ZLIB;
 }
 
 std::optional<size_t> ZlibCompressor::compressionThreshold() const noexcept
 {
     return m_minCompressionSize;
 }
+} // namespace cyrex::network::mcbe::compression
\ No newline at end of file
diff --git a/src/network/mcbe/compression/zlib_compressor.hpp b/src/network/mcbe/compression/zlib_compressor.hpp
index a46ded5..4e25d6d 100644
--- a/src/network/mcbe/compression/zlib_compressor.hpp
+++ b/src/network/mcbe/compression/zlib_compressor.hpp
@@ -4,6 +4,8 @@
 
 #include <libdeflate.h>
 
+namespace cyrex::network::mcbe::compression
+{
 class ZlibCompressor final : public Compressor
 {
 public:
@@ -21,7 +23,7 @@ public:
 
     bool compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) override;
 
-    mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override;
+    cyrex::mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override;
 
     std::optional<size_t> compressionThreshold() const noexcept override;
 
@@ -33,3 +35,4 @@ private:
     libdeflate_compressor* m_compressor;
     libdeflate_decompressor* m_decompressor;
 };
+} // namespace cyrex::network::mcbe::compression
\ No newline at end of file
diff --git a/src/network/mcbe/handler/session_begin_handler.hpp b/src/network/mcbe/handler/session_begin_handler.hpp
index 2a3ba21..bd30e4b 100644
--- a/src/network/mcbe/handler/session_begin_handler.hpp
+++ b/src/network/mcbe/handler/session_begin_handler.hpp
@@ -1,17 +1,22 @@
 #pragma once
 
+#include "network/mcbe/packetbase.hpp"
 #include "network/mcbe/protocol/request_network_settings.hpp"
+#include "network/session/network_session.hpp"
 
-#include<iostream>
+#include <iostream>
+
+namespace cyrex::network::mcbe::handler
+{
 
 // TODO: make an handler base class.
 class SessionBeginHandler
 {
 public:
-    void handle(NetworkSession& session, PacketBase& packet)
+    void handle(cyrex::network::session::NetworkSession& session, cyrex::network::mcbe::PacketBase& packet)
     {
         // theres no way this is actually good, glalie review this, if this is lwk valid, idc yk
-        auto& pk = static_cast<RequestNetworkSettingsPacket&>(packet);
+        auto& pk = static_cast<cyrex::network::mcbe::protocol::RequestNetworkSettingsPacket&>(packet);
         uint32_t version = pk.protocolVersion;
 
         // no guarentee that a protocol is accepted at the moment
@@ -21,12 +26,12 @@ public:
             session.disconnectUserForIncompatiableProtocol(version);
             return;
         }
-        
+
         session.setProtocolId(version);
 
         // this packet needs to be properly handled and we should call session's compressor networkId, right now this is just hardcoded
-        NetworkSettingsPacket pak{};
-        pak.compressionThreshold = NetworkSettingsPacket::COMPRESS_EVERYTHING;
+        cyrex::network::mcbe::protocol::NetworkSettingsPacket pak{};
+        pak.compressionThreshold = cyrex::network::mcbe::protocol::NetworkSettingsPacket::COMPRESS_EVERYTHING;
         pak.compressionAlgorithm = 1;
         pak.padding = 00;
         pak.enableClientThrottling = false;
@@ -41,9 +46,10 @@ public:
     // no way im planning multiprotocol??
     constexpr bool isProtocolMabyeAccepted(std::uint32_t protocol)
     {
-        for (auto p : ProtocolInfo::ACCEPTED_PROTOCOLS)
+        for (auto p : cyrex::network::mcbe::protocol::ProtocolInfo::ACCEPTED_PROTOCOLS)
             if (p == protocol)
                 return true;
         return false;
     }
 };
+} // namespace cyrex::network::mcbe::handler
\ No newline at end of file
diff --git a/src/network/mcbe/mcbe_batch_decoder.cpp b/src/network/mcbe/mcbe_batch_decoder.cpp
index 31e94bb..c8d1944 100644
--- a/src/network/mcbe/mcbe_batch_decoder.cpp
+++ b/src/network/mcbe/mcbe_batch_decoder.cpp
@@ -2,9 +2,11 @@
 
 #include "network/util/binary_stream.hpp"
 
+using namespace cyrex::network::util;
+
 //TODO: use this again, right now it has no official purpose, in test builds, i worked on, this had a purpose
 // However now no longer, this should be recoded, COMPLETELY, its faulty and dont uses session->compressor.
-bool McbeBatchDecoder::decode(const uint8_t* data, size_t len, std::vector<McbeBatchPacket>& out)
+bool cyrex::network::mcbe::McbeBatchDecoder::decode(const uint8_t* data, size_t len, std::vector<McbeBatchPacket>& out)
 {
     if (len < 1)
         return false;
diff --git a/src/network/mcbe/mcbe_batch_decoder.hpp b/src/network/mcbe/mcbe_batch_decoder.hpp
index bfdb354..ecb7ab5 100644
--- a/src/network/mcbe/mcbe_batch_decoder.hpp
+++ b/src/network/mcbe/mcbe_batch_decoder.hpp
@@ -5,6 +5,9 @@
 #include <cstddef>
 #include <cstdint>
 
+namespace cyrex::network::mcbe
+{
+
 struct McbeBatchPacket
 {
     std::vector<uint8_t> data;
@@ -15,3 +18,4 @@ class McbeBatchDecoder
 public:
     static bool decode(const uint8_t* data, size_t len, std::vector<McbeBatchPacket>& outPackets);
 };
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/mcbe/packet.hpp b/src/network/mcbe/packet.hpp
index 5e7dd06..e209251 100644
--- a/src/network/mcbe/packet.hpp
+++ b/src/network/mcbe/packet.hpp
@@ -1,20 +1,18 @@
 #pragma once
 
-#include "packetbase.hpp"
-#include "network/util/binary_stream.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
+#include "network/session/network_session.hpp"
+#include "network/util/binary_stream.hpp"
+#include "packetbase.hpp"
+
+using namespace cyrex::network::util;
+
+namespace cyrex::network::mcbe
+{
 
 class Packet : public PacketBase
 {
 public:
-    static constexpr uint32_t ID_MASK = 0x3FF;
-    static constexpr uint32_t SUBCLIENT_MASK = 0x03;
-    static constexpr uint32_t SENDER_SHIFT = 10;
-    static constexpr uint32_t RECIPIENT_SHIFT = 12;
-
-    uint8_t senderSubId = 0;
-    uint8_t recipientSubId = 0;
-
     void decode(BinaryStream& in) final
     {
         decodePayload(in);
@@ -28,7 +26,7 @@ public:
         BinaryStream payload;
         encodePayload(payload);
 
-        out.writeU8(0xFE); 
+        out.writeU8(0xFE);
         out.writeI8(static_cast<int8_t>(payload.length() + 1)); // + packetId
         out.writeU8(static_cast<uint8_t>(networkId()));
 
@@ -40,3 +38,4 @@ protected:
     virtual void decodePayload(BinaryStream& in) = 0;
     virtual void encodePayload(BinaryStream& out) const = 0;
 };
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/mcbe/packet_direction.hpp b/src/network/mcbe/packet_direction.hpp
index 7e63d52..17759f0 100644
--- a/src/network/mcbe/packet_direction.hpp
+++ b/src/network/mcbe/packet_direction.hpp
@@ -1,9 +1,14 @@
 #pragma once
 #include <cstdint>
 
+namespace cyrex::network::mcbe
+{
+
 enum class PacketDirection : uint8_t
 {
     Clientbound = 1,
     Serverbound = 2,
     Bidirectional = 3
 };
+
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/mcbe/packet_pool.cpp b/src/network/mcbe/packet_pool.cpp
index 50feb47..6325e78 100644
--- a/src/network/mcbe/packet_pool.cpp
+++ b/src/network/mcbe/packet_pool.cpp
@@ -1,15 +1,27 @@
 #include "network/mcbe/packet_pool.hpp"
 
-#include "protocol/request_network_settings.hpp"
-#include "protocol/network_settings.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
 #include "protocol/login.hpp"
+#include "protocol/network_settings.hpp"
 #include "protocol/play_status.hpp"
-#include "network/mcbe/protocol/protocol_info.hpp"
+#include "protocol/request_network_settings.hpp"
 
-void PacketPool::registerAll()
+void cyrex::network::mcbe::PacketPool::registerAll()
 {
-    bind(ProtocolInfo::REQUEST_NETWORK_SETTINGS_PACKET, [] { return std::make_unique<RequestNetworkSettingsPacket>(); }, PacketDirection::Serverbound);
-    bind(ProtocolInfo::NETWORK_SETTINGS_PACKET, [] { return std::make_unique<NetworkSettingsPacket>(); }, PacketDirection::Clientbound);
-    bind(ProtocolInfo::LOGIN_PACKET, [] { return std::make_unique<LoginPacket>(); }, PacketDirection::Serverbound);
-    bind(ProtocolInfo::PLAY_STATUS_PACKET, [] { return std::make_unique<PlayStatusPacket>(); }, PacketDirection::Clientbound);
+    bind(
+        cyrex::network::mcbe::protocol::ProtocolInfo::REQUEST_NETWORK_SETTINGS_PACKET,
+        [] { return std::make_unique<cyrex::network::mcbe::protocol::RequestNetworkSettingsPacket>(); },
+        PacketDirection::Serverbound);
+    bind(
+        cyrex::network::mcbe::protocol::ProtocolInfo::NETWORK_SETTINGS_PACKET,
+        [] { return std::make_unique<cyrex::network::mcbe::protocol::NetworkSettingsPacket>(); },
+        PacketDirection::Clientbound);
+    bind(
+        cyrex::network::mcbe::protocol::ProtocolInfo::LOGIN_PACKET,
+        [] { return std::make_unique<cyrex::network::mcbe::protocol::LoginPacket>(); },
+        PacketDirection::Serverbound);
+    bind(
+        cyrex::network::mcbe::protocol::ProtocolInfo::PLAY_STATUS_PACKET,
+        [] { return std::make_unique<cyrex::network::mcbe::protocol::PlayStatusPacket>(); },
+        PacketDirection::Clientbound);
 }
diff --git a/src/network/mcbe/packet_pool.hpp b/src/network/mcbe/packet_pool.hpp
index 5bc8cba..f579fe8 100644
--- a/src/network/mcbe/packet_pool.hpp
+++ b/src/network/mcbe/packet_pool.hpp
@@ -7,6 +7,9 @@
 #include <memory>
 #include <unordered_map>
 
+namespace cyrex::network::mcbe
+{
+
 class PacketPool
 {
 public:
@@ -51,3 +54,4 @@ public:
 private:
     std::unordered_map<uint32_t, Entry> entries;
 };
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/mcbe/packetbase.hpp b/src/network/mcbe/packetbase.hpp
index 9633ba2..23e17c3 100644
--- a/src/network/mcbe/packetbase.hpp
+++ b/src/network/mcbe/packetbase.hpp
@@ -1,11 +1,17 @@
 #pragma once
 
-#include <string>
+#include "network/util/binary_stream.hpp"
 #include "packet_direction.hpp"
+
 #include <cstdint>
 
-class BinaryStream;
+namespace cyrex::network::session
+{
 class NetworkSession;
+}
+
+namespace cyrex::network::mcbe
+{
 
 class PacketBase
 {
@@ -16,8 +22,9 @@ public:
     virtual PacketDirection direction() const = 0;
     virtual bool allowBeforeLogin() const = 0;
 
-    virtual void decode(BinaryStream& in) = 0;
-    virtual void encode(BinaryStream& out) const = 0;
+    virtual void decode(cyrex::network::util::BinaryStream& in) = 0;
+    virtual void encode(cyrex::network::util::BinaryStream& out) const = 0;
 
-    virtual bool handle(NetworkSession& session) = 0;
+    virtual bool handle(cyrex::network::session::NetworkSession& session) = 0;
 };
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/login.hpp b/src/network/mcbe/protocol/login.hpp
index 66de761..c80061a 100644
--- a/src/network/mcbe/protocol/login.hpp
+++ b/src/network/mcbe/protocol/login.hpp
@@ -2,11 +2,17 @@
 
 #include "network/mcbe/packet.hpp"
 #include "network/mcbe/packet_direction.hpp"
+#include "network/session/network_session.hpp"
 #include "util/textformat.hpp"
 
 #include <iostream>
 
-class LoginPacket final : public Packet
+using namespace cyrex::network::util;
+using namespace cyrex::network::session;
+
+namespace cyrex::network::mcbe::protocol
+{
+class LoginPacket final : public cyrex::network::mcbe::Packet
 {
 public:
     uint32_t protocol = 0;
@@ -18,9 +24,9 @@ public:
         return ProtocolInfo::LOGIN_PACKET;
     }
 
-    PacketDirection direction() const override
+    cyrex::network::mcbe::PacketDirection direction() const override
     {
-        return PacketDirection::Serverbound;
+        return cyrex::network::mcbe::PacketDirection::Serverbound;
     }
 
     bool allowBeforeLogin() const override
@@ -32,12 +38,12 @@ protected:
     void decodePayload(BinaryStream& in) override
     {
         protocol = in.readU32BE();
-        std::cout
-            << (util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::GREEN) + "[MCBE] ", true) +
-                util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::EMERALD) +
-                                                    "Received Protocol Version (LoginPacket): ",
-                                                false))
-            << protocol << std::endl;
+        std::cout << (cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::GREEN) + "[MCBE] ", true) +
+                      cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::EMERALD) + "Received "
+                                                                                                     "Protocol Version "
+                                                                                                     "(LoginPacket): ",
+                                                 false))
+                  << protocol << std::endl;
         std::string connectionRequest = in.readString();
         tryDecodeRequestForConnection(connectionRequest);
     }
@@ -81,3 +87,4 @@ private:
         return std::string(reinterpret_cast<const char*>(cr.data()), cr.length());
     }
 };
+} // namespace cyrex::network::mcbe::protocol
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/network_settings.hpp b/src/network/mcbe/protocol/network_settings.hpp
index 4a89423..dd2d912 100644
--- a/src/network/mcbe/protocol/network_settings.hpp
+++ b/src/network/mcbe/protocol/network_settings.hpp
@@ -1,12 +1,18 @@
 ﻿#pragma once
 
 #include "network/mcbe/packet.hpp"
+#include "network/mcbe/packet_direction.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
 #include "network/util/binary_stream.hpp"
 
 #include <cstdint>
 
-class NetworkSettingsPacket final : public Packet
+using namespace cyrex::network::util;
+using namespace cyrex::network::session;
+
+namespace cyrex::network::mcbe::protocol
+{
+class NetworkSettingsPacket final : public cyrex::network::mcbe::Packet
 {
 public:
     static constexpr uint16_t COMPRESS_NOTHING = 0;
@@ -28,9 +34,9 @@ public:
         return ProtocolInfo::NETWORK_SETTINGS_PACKET;
     }
 
-    PacketDirection direction() const override
+    cyrex::network::mcbe::PacketDirection direction() const override
     {
-        return PacketDirection::Clientbound;
+        return cyrex::network::mcbe::PacketDirection::Clientbound;
     }
 
     bool allowBeforeLogin() const override
@@ -60,4 +66,5 @@ public:
     {
         return true;
     }
-};
\ No newline at end of file
+};
+} // namespace cyrex::network::mcbe::protocol
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/play_status.hpp b/src/network/mcbe/protocol/play_status.hpp
index 27ed725..e261352 100644
--- a/src/network/mcbe/protocol/play_status.hpp
+++ b/src/network/mcbe/protocol/play_status.hpp
@@ -1,12 +1,18 @@
 #pragma once
 
 #include "network/mcbe/packet.hpp"
+#include "network/mcbe/packet_direction.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
 #include "network/util/binary_stream.hpp"
 
 #include <cstdint>
 
-class PlayStatusPacket final : public Packet
+using namespace cyrex::network::util;
+using namespace cyrex::network::session;
+
+namespace cyrex::network::mcbe::protocol
+{
+class PlayStatusPacket final : public cyrex::network::mcbe::Packet
 {
 public:
     // Mabye make this separately?
@@ -28,9 +34,9 @@ public:
         return ProtocolInfo::PLAY_STATUS_PACKET;
     }
 
-    PacketDirection direction() const override
+    cyrex::network::mcbe::PacketDirection direction() const override
     {
-        return PacketDirection::Clientbound;
+        return cyrex::network::mcbe::PacketDirection::Clientbound;
     }
 
     bool allowBeforeLogin() const override
@@ -55,3 +61,4 @@ public:
         return true;
     }
 };
+} // namespace cyrex::network::mcbe::protocol
diff --git a/src/network/mcbe/protocol/protocol_info.hpp b/src/network/mcbe/protocol/protocol_info.hpp
index d1bf70c..58f1746 100644
--- a/src/network/mcbe/protocol/protocol_info.hpp
+++ b/src/network/mcbe/protocol/protocol_info.hpp
@@ -1,17 +1,19 @@
 #pragma once
 
-#include <cstdint>
 #include <array>
 
+#include <cstdint>
+
+namespace cyrex::network::mcbe::protocol
+{
+
 struct ProtocolInfo
 {
     static constexpr std::uint32_t CURRENT_PROTOCOL = 898;
     static constexpr const char* MINECRAFT_VERSION = "v1.21.130";
     static constexpr const char* MINECRAFT_VERSION_NETWORK = "1.21.130";
 
-    static constexpr std::array<std::uint32_t, 1> ACCEPTED_PROTOCOLS = {
-        CURRENT_PROTOCOL
-    };
+    static constexpr std::array<std::uint32_t, 1> ACCEPTED_PROTOCOLS = {CURRENT_PROTOCOL};
 
     static constexpr std::uint8_t LOGIN_PACKET = 0x01;
     static constexpr std::uint8_t PLAY_STATUS_PACKET = 0x02;
@@ -25,4 +27,6 @@ struct ProtocolInfo
     static constexpr std::uint8_t CHUNK_RADIUS_UPDATED_PACKET = 0x46;
     static constexpr std::uint8_t NETWORK_SETTINGS_PACKET = 0x8f;
     static constexpr std::uint8_t REQUEST_NETWORK_SETTINGS_PACKET = 0xc1;
-};
\ No newline at end of file
+};
+
+} // namespace cyrex::network::mcbe::protocol
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/request_network_settings.hpp b/src/network/mcbe/protocol/request_network_settings.hpp
index d63c694..31a98c1 100644
--- a/src/network/mcbe/protocol/request_network_settings.hpp
+++ b/src/network/mcbe/protocol/request_network_settings.hpp
@@ -1,18 +1,27 @@
 #pragma once
 
 #include "network/mcbe/packet.hpp"
+#include "network/mcbe/packet_direction.hpp"
+#include "network/mcbe/protocol/network_settings.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
-#include "network/util/binary_stream.hpp"
+#include "network/mcbe/protocol/types/CompressionAlgorithm.hpp"
 #include "network/session/network_session.hpp"
-#include "network/mcbe/protocol/network_settings.hpp"
+#include "network/util/binary_stream.hpp"
 #include "util/textformat.hpp"
-#include "network/mcbe/protocol/types/CompressionAlgorithm.hpp"
-#include <RakNet/RakNetTypes.h>
 
+#include <RakNet/RakNetTypes.h>
 #include <iostream>
+
 #include <cstdint>
 
-class RequestNetworkSettingsPacket final : public Packet
+// is this valid?
+using namespace cyrex::network::util;
+using namespace cyrex::network::session;
+
+namespace cyrex::network::mcbe::protocol
+{
+
+class RequestNetworkSettingsPacket final : public cyrex::network::mcbe::Packet
 {
 public:
     uint32_t protocolVersion = 0;
@@ -22,9 +31,9 @@ public:
         return ProtocolInfo::REQUEST_NETWORK_SETTINGS_PACKET;
     }
 
-    PacketDirection direction() const override
+    cyrex::network::mcbe::PacketDirection direction() const override
     {
-        return PacketDirection::Serverbound;
+        return cyrex::network::mcbe::PacketDirection::Serverbound;
     }
 
     bool allowBeforeLogin() const override
@@ -36,12 +45,14 @@ protected:
     void decodePayload(BinaryStream& in) override
     {
         protocolVersion = in.readU32BE();
-        std::cout
-            << (util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::GREEN) + "[MCBE] ", true) +
-                util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::EMERALD) +
-                                                    "Received Protocol Version (RequestNetworkSettings): ",
-                                                false))
-            << protocolVersion << std::endl;
+        std::cout << (cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::GREEN) + "[MCBE] ", true) +
+                      cyrex::util::renderConsole(cyrex::util::bedrock(cyrex::util::Color::EMERALD) +
+                                                     "Received "
+                                                     "Protocol Version "
+                                                     "(RequestNetworkSe"
+                                                     "ttings): ",
+                                                 false))
+                  << protocolVersion << std::endl;
     }
 
     void encodePayload(BinaryStream&) const override
@@ -56,3 +67,4 @@ public:
         return true;
     }
 };
+} // namespace cyrex::network::mcbe::protocol
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp b/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp
index 1caec92..bf802d1 100644
--- a/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp
+++ b/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp
@@ -2,7 +2,7 @@
 
 #include <cstdint>
 
-namespace mcpe::protocol::types
+namespace cyrex::mcpe::protocol::types
 {
 enum class CompressionAlgorithm : std::uint8_t
 {
@@ -10,4 +10,4 @@ enum class CompressionAlgorithm : std::uint8_t
     SNAPPY = 1,
     NONE = 0xFF
 };
-} // namespace mcpe::protocol::types
+} // namespace cyrex::mcpe::protocol::types
diff --git a/src/network/mcbe/protocol/types/GameMode.hpp b/src/network/mcbe/protocol/types/GameMode.hpp
index 1516fa5..1c19d64 100644
--- a/src/network/mcbe/protocol/types/GameMode.hpp
+++ b/src/network/mcbe/protocol/types/GameMode.hpp
@@ -3,7 +3,7 @@
 
 #include <cstdint>
 
-namespace mcpe::protocol::types
+namespace cyrex::mcpe::protocol::types
 {
 
 // somewhat valid implemention, i wouldnt say fully but eh it works
@@ -87,4 +87,4 @@ constexpr GameMode fromString(std::string_view str) noexcept
     return GameMode::DEFAULT;
 }
 
-} // namespace mcpe::protocol::types
+} // namespace cyrex::mcpe::protocol::types
diff --git a/src/network/mcbe/transport.hpp b/src/network/mcbe/transport.hpp
index f8f7e58..0553e90 100644
--- a/src/network/mcbe/transport.hpp
+++ b/src/network/mcbe/transport.hpp
@@ -5,6 +5,9 @@
 #include <cstddef>
 #include <cstdint>
 
+namespace cyrex::network::mcbe
+{
+
 class Transport
 {
 public:
@@ -12,3 +15,4 @@ public:
 
     virtual void send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len) = 0;
 };
+} // namespace cyrex::network::mcbe
\ No newline at end of file
diff --git a/src/network/raknet/mcbe_packet_router.cpp b/src/network/raknet/mcbe_packet_router.cpp
index e666bdc..d7e91e2 100644
--- a/src/network/raknet/mcbe_packet_router.cpp
+++ b/src/network/raknet/mcbe_packet_router.cpp
@@ -1,15 +1,88 @@
 #include "mcbe_packet_router.hpp"
 
+#include <iostream>
+#include "util/textformat.hpp"
 #include "network/session/network_session.hpp"
+using namespace cyrex::network::session;
+using namespace cyrex::util;
 
-void McbePacketRouter::route(RakNet::Packet* p, RaknetConnections& connections)
+void cyrex::network::raknet::McbePacketRouter::route(RakNet::Packet* p, cyrex::network::raknet::RaknetConnections& connections)
 {
-    if (p->length <= 1)
+    cyrex::network::session::NetworkSession* session = connections.get(p->guid);
+    if (!session)
         return;
 
-    auto* session = connections.get(p->guid);
-    if (!session)
+    const uint8_t* data = p->data + 1;
+    size_t len = p->length - 1;
+
+    if (len == 0)
         return;
 
-    session->onRaw(*p, p->data + 1, p->length - 1);
+    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
+    //          << renderConsole(bedrock(Color::DARK_GRAY) + " raw payload ", false) << "(" << len << " bytes) : ";
+
+    //for (size_t i = 0; i < len; i++)
+    //    std::printf("%02X ", data[i]);
+    //std::cout << std::endl;
+
+    std::vector<uint8_t> payload;
+
+    if (!session->compressionEnabled)
+    {
+        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
+                  << renderConsole(bedrock(Color::GRAY) + " compression DISABLED", false) << std::endl;
+
+        payload.assign(data, data + len);
+    }
+    else
+    {
+        uint8_t compressionMethod = data[0];
+
+        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                  << renderConsole(bedrock(Color::DARK_GRAY) + " compression method = 0x", false) << std::hex
+                  << (int)compressionMethod << std::dec << std::endl;
+
+        const uint8_t* body = data + 1;
+        size_t bodyLen = len - 1;
+
+        if (compressionMethod == 0xFF)
+        {
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " no compression", false) << std::endl;
+
+            payload.assign(body, body + bodyLen);
+        }
+        else if (compressionMethod == 0x00)
+        {
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " ZLIB decompressing...", false) << std::endl;
+
+            if (!session->compressor().decompress(body, bodyLen, payload))
+            {
+                std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
+                          << renderConsole(bedrock(Color::DARK_GRAY) + " decompression failed", false) << std::endl;
+                return;
+            }
+
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " decompressed size = ", false) << payload.size()
+                      << std::endl;
+        }
+        else
+        {
+            std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
+                      << renderConsole(bedrock(Color::DARK_GRAY) + " unknown compression method = ", false)
+                      << (int)compressionMethod << std::endl;
+            return;
+        }
+    }
+
+    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+    //          << renderConsole(bedrock(Color::GRAY) + " final payload: ", false);
+
+    /*   for (uint8_t b : payload)
+        std::printf("%02X ", b);
+    std::cout << std::endl;*/
+
+    session->onRaw(*p, payload.data(), payload.size());
 }
diff --git a/src/network/raknet/mcbe_packet_router.hpp b/src/network/raknet/mcbe_packet_router.hpp
index 277634d..42d7e59 100644
--- a/src/network/raknet/mcbe_packet_router.hpp
+++ b/src/network/raknet/mcbe_packet_router.hpp
@@ -1,8 +1,11 @@
 #pragma once
 #include "raknet_connections.hpp"
 
+namespace cyrex::network::raknet
+{
 class McbePacketRouter
 {
 public:
-    static void route(RakNet::Packet* p, RaknetConnections& connections);
+    static void route(RakNet::Packet* p, cyrex::network::raknet::RaknetConnections& connections);
 };
+} // namespace cyrex::network::raknet
\ No newline at end of file
diff --git a/src/network/raknet/raknet_connections.cpp b/src/network/raknet/raknet_connections.cpp
index 0d055c9..cf959a4 100644
--- a/src/network/raknet/raknet_connections.cpp
+++ b/src/network/raknet/raknet_connections.cpp
@@ -3,15 +3,19 @@
 #include "network/session/network_session.hpp"
 #include "raknet_handler.hpp"
 #include "util/textformat.hpp"
+#include "network/mcbe/compression/zlib_compressor.hpp"
 
 #include <iostream>
-using namespace util::textformat;
 
-void RaknetConnections::onConnect(const RakNet::RakNetGUID& guid, RakNet::SystemAddress address, RaknetHandler* handler)
+using namespace cyrex::util;
+
+void cyrex::network::raknet::RaknetConnections::onConnect(const RakNet::RakNetGUID& guid,
+                                                        RakNet::SystemAddress address,
+                                                          cyrex::network::raknet::RaknetHandler* handler)
 {
-    auto session = std::make_unique<NetworkSession>(guid, address, handler->transport());
+    auto session = std::make_unique<cyrex::network::session::NetworkSession>(guid, address, handler->transport());
 
-    session->setCompressor(std::make_unique<ZlibCompressor>(6, std::optional<size_t>{0}, 2 * 1024 * 1024));
+    session->setCompressor(std::make_unique<cyrex::network::mcbe::compression::ZlibCompressor>(6, std::optional<size_t>{0}, 2 * 1024 * 1024));
 
     sessions.emplace(guid, std::move(session));
 
@@ -19,16 +23,18 @@ void RaknetConnections::onConnect(const RakNet::RakNetGUID& guid, RakNet::System
               << std::endl;
 }
 
-void RaknetConnections::onDisconnect(const RakNet::RakNetGUID& guid)
+void cyrex::network::raknet::RaknetConnections::onDisconnect(const RakNet::RakNetGUID& guid)
 {
     sessions.erase(guid);
-    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] ", true) + renderConsole(bedrock(Color::DARK_GRAY) + "Disconnected client ", false) << std::endl;
+    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] " + bedrock(Color::DARK_GRAY) + "Client disconnected", true)
+              << std::endl;
 }
 
-NetworkSession* RaknetConnections::get(const RakNet::RakNetGUID& guid)
+cyrex::network::session::NetworkSession* cyrex::network::raknet::RaknetConnections::get(const RakNet::RakNetGUID& guid)
 {
     auto it = sessions.find(guid);
     if (it == sessions.end())
         return nullptr;
+
     return it->second.get();
 }
diff --git a/src/network/raknet/raknet_connections.hpp b/src/network/raknet/raknet_connections.hpp
index 76fb88f..30b283e 100644
--- a/src/network/raknet/raknet_connections.hpp
+++ b/src/network/raknet/raknet_connections.hpp
@@ -1,4 +1,4 @@
-#pragma once
+﻿#pragma once
 
 #include "raknet_guid_hash.hpp"
 
@@ -6,16 +6,25 @@
 #include <memory>
 #include <unordered_map>
 
+namespace cyrex::network::session
+{
 class NetworkSession;
+}
+
+namespace cyrex::network::raknet
+{
 class RaknetHandler;
 
 class RaknetConnections
 {
 public:
     void onConnect(const RakNet::RakNetGUID& guid, RakNet::SystemAddress address, RaknetHandler* handler);
+
     void onDisconnect(const RakNet::RakNetGUID& guid);
-    NetworkSession* get(const RakNet::RakNetGUID& guid);
+
+    cyrex::network::session::NetworkSession* get(const RakNet::RakNetGUID& guid);
 
 private:
-    std::unordered_map<RakNet::RakNetGUID, std::unique_ptr<NetworkSession>> sessions;
+    std::unordered_map<RakNet::RakNetGUID, std::unique_ptr<cyrex::network::session::NetworkSession>> sessions;
 };
+} // namespace cyrex::network::raknet
diff --git a/src/network/raknet/raknet_guid_hash.hpp b/src/network/raknet/raknet_guid_hash.hpp
index 79ee971..13afcb6 100644
--- a/src/network/raknet/raknet_guid_hash.hpp
+++ b/src/network/raknet/raknet_guid_hash.hpp
@@ -3,6 +3,7 @@
 #include <RakNet/RakNetTypes.h>
 #include <functional>
 
+// does this need a namespace? -- probably not
 namespace std
 {
 template <>
diff --git a/src/network/raknet/raknet_handler.cpp b/src/network/raknet/raknet_handler.cpp
index b83bf73..fc0b52a 100644
--- a/src/network/raknet/raknet_handler.cpp
+++ b/src/network/raknet/raknet_handler.cpp
@@ -2,24 +2,22 @@
 
 #include "network/session/network_session.hpp"
 #include "raknet_motd.hpp"
+#include "raknet_transport.hpp"
 #include "server.hpp"
-
+#include "mcbe_packet_router.hpp"
 #include "util/textformat.hpp"
-#include "raknet_transport.hpp"
 
 #include <iostream>
-using namespace util::textformat;
+using namespace cyrex::util;
 
-RaknetHandler::RaknetHandler()
+cyrex::network::raknet::RaknetHandler::RaknetHandler()
 {
-    Server& server = Server::getInstance();
+    cyrex::Server& server = cyrex::Server::getInstance();
 
-    peer = RakNet::RakPeerInterface::GetInstance();
-    RakNet::SocketDescriptor sd(server.getPort(), nullptr);
-    peer->Startup(server.getMaxPlayers(), &sd, 1);
-    peer->SetMaximumIncomingConnections(server.getMaxPlayers());
+    peer = std::make_unique<cyrex::network::raknet::RaknetPeer>(server.getPort(), server.getMaxPlayers());
+    RakNet::RakPeerInterface* rakPeer = peer->get();
 
-    std::string motd = buildRaknetMotd();
+    std::string motd = cyrex::network::raknet::buildRaknetMotd();
     std::string response;
 
     uint16_t len = static_cast<uint16_t>(motd.size());
@@ -27,128 +25,40 @@ RaknetHandler::RaknetHandler()
     response.push_back(len & 0xFF);
     response += motd;
 
-    peer->SetOfflinePingResponse(response.c_str(), response.size());
+    rakPeer->SetOfflinePingResponse(response.c_str(), response.size());
 
-    transportImpl = std::make_unique<RaknetTransport>(peer);
-    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] ", true) + renderConsole(bedrock(Color::DARK_GRAY) + "listening on ", false) << server.getPort() << std::endl;
-}
+    transportImpl = std::make_unique<cyrex::network::raknet::RaknetTransport>(rakPeer);
 
-RaknetHandler::~RaknetHandler()
-{
-    RakNet::RakPeerInterface::DestroyInstance(peer);
+    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] ", true)
+              << renderConsole(bedrock(Color::DARK_GRAY) + "listening on ", false) << server.getPort() << std::endl;
 }
 
-Transport* RaknetHandler::transport()
+cyrex::network::raknet::RaknetHandler::~RaknetHandler() = default;
+
+cyrex::network::mcbe::Transport* cyrex::network::raknet::RaknetHandler::transport()
 {
     return transportImpl.get();
 }
 
-void RaknetHandler::poll()
+void cyrex::network::raknet::RaknetHandler::poll()
 {
-    for (RakNet::Packet* p = peer->Receive(); p; peer->DeallocatePacket(p), p = peer->Receive())
-    {
-        handlePacket(p);
-    }
-}
+    RakNet::RakPeerInterface* rakPeer = peer->get();
 
-void RaknetHandler::handlePacket(RakNet::Packet* p)
-{
-    switch (p->data[0])
+    for (RakNet::Packet* p = rakPeer->Receive(); p; rakPeer->DeallocatePacket(p), p = rakPeer->Receive())
     {
-        case 0x13:
-            connections.onConnect(p->guid, p->systemAddress, this);
-            break;
-
-        case 0x15:
-            connections.onDisconnect(p->guid);
-            break;
-
-        case 0xFE:
-            handleMcbePacket(p);
-            break;
-
-        default:
-            break;
+        handlePacket(p);
     }
 }
 
-void RaknetHandler::handleMcbePacket(RakNet::Packet* p)
+void cyrex::network::raknet::RaknetHandler::handlePacket(RakNet::Packet* p)
 {
-    NetworkSession* session = connections.get(p->guid);
-    if (!session)
-        return;
-
-    const uint8_t* data = p->data + 1;
-    size_t len = p->length - 1;
-
-    if (len == 0)
-        return;
-
-    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
-    //          << renderConsole(bedrock(Color::DARK_GRAY) + " raw payload ", false) << "(" << len << " bytes) : ";
-
-    //for (size_t i = 0; i < len; i++)
-    //    std::printf("%02X ", data[i]);
-    //std::cout << std::endl;
-
-    std::vector<uint8_t> payload;
-
-    if (!session->compressionEnabled)
-    {
-        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
-                  << renderConsole(bedrock(Color::GRAY) + " compression DISABLED", false) << std::endl;
-
-        payload.assign(data, data + len);
-    }
-    else
-    {
-        uint8_t compressionMethod = data[0];
-
-        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
-                  << renderConsole(bedrock(Color::DARK_GRAY) + " compression method = 0x", false) << std::hex
-                  << (int)compressionMethod << std::dec << std::endl;
-
-        const uint8_t* body = data + 1;
-        size_t bodyLen = len - 1;
-
-        if (compressionMethod == 0xFF)
-        {
-            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
-                      << renderConsole(bedrock(Color::GRAY) + " no compression", false) << std::endl;
-
-            payload.assign(body, body + bodyLen);
-        }
-        else if (compressionMethod == 0x00)
-        {
-            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
-                      << renderConsole(bedrock(Color::GRAY) + " ZLIB decompressing...", false) << std::endl;
-
-            if (!session->compressor().decompress(body, bodyLen, payload))
-            {
-                std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
-                          << renderConsole(bedrock(Color::DARK_GRAY) + " decompression failed", false) << std::endl;
-                return;
-            }
-
-            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
-                      << renderConsole(bedrock(Color::GRAY) + " decompressed size = ", false) << payload.size()
-                      << std::endl;
-        }
-        else
-        {
-            std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
-                      << renderConsole(bedrock(Color::DARK_GRAY) + " unknown compression method = ", false)
-                      << (int)compressionMethod << std::endl;
-            return;
-        }
-    }
-
-    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
-    //          << renderConsole(bedrock(Color::GRAY) + " final payload: ", false);
-
- /*   for (uint8_t b : payload)
-        std::printf("%02X ", b);
-    std::cout << std::endl;*/
-
-    session->onRaw(*p, payload.data(), payload.size());
+    const uint8_t id = p->data[0];
+
+    // from switch to this, probably not too big of an impact, but eh
+    if (id == 0x13)
+        connections.onConnect(p->guid, p->systemAddress, this);
+    else if (id == 0x15)
+        connections.onDisconnect(p->guid);
+    else if (id == 0xFE)
+        cyrex::network::raknet::McbePacketRouter::route(p, connections);
 }
\ No newline at end of file
diff --git a/src/network/raknet/raknet_handler.hpp b/src/network/raknet/raknet_handler.hpp
index b207306..5c0e0d6 100644
--- a/src/network/raknet/raknet_handler.hpp
+++ b/src/network/raknet/raknet_handler.hpp
@@ -2,9 +2,13 @@
 
 #include "network/mcbe/transport.hpp"
 #include "raknet_connections.hpp"
+#include "raknet_peer.hpp"
 
 #include <RakNet/RakNetTypes.h>
-#include <RakNet/RakPeerInterface.h>
+#include <memory>
+
+namespace cyrex::network::raknet
+{
 
 class RaknetHandler
 {
@@ -14,15 +18,16 @@ public:
 
     void poll();
 
-    Transport* transport();
+    cyrex::network::mcbe::Transport* transport();
 
 private:
     void handlePacket(RakNet::Packet* p);
-    void handleMcbePacket(RakNet::Packet* p);
 
 private:
-    RakNet::RakPeerInterface* peer;
+    std::unique_ptr<RaknetPeer> peer;
     RaknetConnections connections;
 
-    std::unique_ptr<Transport> transportImpl;
+    std::unique_ptr<cyrex::network::mcbe::Transport> transportImpl;
 };
+
+} // namespace cyrex::network::raknet
diff --git a/src/network/raknet/raknet_motd.cpp b/src/network/raknet/raknet_motd.cpp
index 73211e4..a871a4f 100644
--- a/src/network/raknet/raknet_motd.cpp
+++ b/src/network/raknet/raknet_motd.cpp
@@ -1,26 +1,27 @@
 #include "raknet_motd.hpp"
 
+#include "network/mcbe/protocol/types/GameMode.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
 #include "server.hpp"
 
-std::string buildRaknetMotd()
+std::string cyrex::network::raknet::buildRaknetMotd()
 {
-    Server& server = Server::getInstance();
+    cyrex::Server& server = cyrex::Server::getInstance();
     auto gm = server.getDefaultGameMode();
 
     int gmNumeric = 1;
-    if (gm == mcpe::protocol::types::GameMode::CREATIVE)
+    if (gm == cyrex::mcpe::protocol::types::GameMode::CREATIVE)
         gmNumeric = 0;
-    if (gm == mcpe::protocol::types::GameMode::ADVENTURE)
+    if (gm == cyrex::mcpe::protocol::types::GameMode::ADVENTURE)
         gmNumeric = 2;
 
     std::string motd;
     motd += "MCPE;";
     motd += server.getMotd();
     motd += ";";
-    motd += std::to_string(ProtocolInfo::CURRENT_PROTOCOL);
+    motd += std::to_string(cyrex::network::mcbe::protocol::ProtocolInfo::CURRENT_PROTOCOL);
     motd += ";";
-    motd += ProtocolInfo::MINECRAFT_VERSION_NETWORK;
+    motd += cyrex::network::mcbe::protocol::ProtocolInfo::MINECRAFT_VERSION_NETWORK;
     motd += ";";
     motd += std::to_string(server.getPlayerCount());
     motd += ";";
diff --git a/src/network/raknet/raknet_motd.hpp b/src/network/raknet/raknet_motd.hpp
index ce316eb..04698fe 100644
--- a/src/network/raknet/raknet_motd.hpp
+++ b/src/network/raknet/raknet_motd.hpp
@@ -1,4 +1,7 @@
 #pragma once
 #include <string>
 
-std::string buildRaknetMotd();
+namespace cyrex::network::raknet
+{
+    std::string buildRaknetMotd();
+}
\ No newline at end of file
diff --git a/src/network/raknet/raknet_peer.cpp b/src/network/raknet/raknet_peer.cpp
index 97926ad..a772587 100644
--- a/src/network/raknet/raknet_peer.cpp
+++ b/src/network/raknet/raknet_peer.cpp
@@ -1,6 +1,6 @@
 #include "raknet_peer.hpp"
 
-RaknetPeer::RaknetPeer(uint16_t port, uint32_t maxPlayers)
+cyrex::network::raknet::RaknetPeer::RaknetPeer(uint16_t port, uint32_t maxPlayers)
 {
     peer = RakNet::RakPeerInterface::GetInstance();
     RakNet::SocketDescriptor sd(port, nullptr);
@@ -8,12 +8,12 @@ RaknetPeer::RaknetPeer(uint16_t port, uint32_t maxPlayers)
     peer->SetMaximumIncomingConnections(maxPlayers);
 }
 
-RaknetPeer::~RaknetPeer()
+cyrex::network::raknet::RaknetPeer::~RaknetPeer()
 {
     RakNet::RakPeerInterface::DestroyInstance(peer);
 }
 
-RakNet::RakPeerInterface* RaknetPeer::get()
+RakNet::RakPeerInterface* cyrex::network::raknet::RaknetPeer::get()
 {
     return peer;
 }
diff --git a/src/network/raknet/raknet_peer.hpp b/src/network/raknet/raknet_peer.hpp
index 0981196..8048b9c 100644
--- a/src/network/raknet/raknet_peer.hpp
+++ b/src/network/raknet/raknet_peer.hpp
@@ -1,6 +1,8 @@
 #pragma once
 #include <RakNet/RakPeerInterface.h>
 
+namespace cyrex::network::raknet
+{
 class RaknetPeer
 {
 public:
@@ -12,3 +14,4 @@ public:
 private:
     RakNet::RakPeerInterface* peer;
 };
+} // namespace cyrex::network::raknet
\ No newline at end of file
diff --git a/src/network/raknet/raknet_transport.cpp b/src/network/raknet/raknet_transport.cpp
index 5695878..5c36c78 100644
--- a/src/network/raknet/raknet_transport.cpp
+++ b/src/network/raknet/raknet_transport.cpp
@@ -1,7 +1,7 @@
 #include "raknet_transport.hpp"
 #include <iostream>
 
-void RaknetTransport::send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len)
+void cyrex::network::raknet::RaknetTransport::send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len)
 {
     peer->Send(reinterpret_cast<const char*>(data), len, HIGH_PRIORITY, RELIABLE_ORDERED, 0, guid, false);
 }
diff --git a/src/network/raknet/raknet_transport.hpp b/src/network/raknet/raknet_transport.hpp
index 8ec014c..b14bde8 100644
--- a/src/network/raknet/raknet_transport.hpp
+++ b/src/network/raknet/raknet_transport.hpp
@@ -5,7 +5,10 @@
 #include <RakNet/RakNetTypes.h>
 #include <RakNet/RakPeerInterface.h>
 
-class RaknetTransport : public Transport
+namespace cyrex::network::raknet
+{
+
+class RaknetTransport : public cyrex::network::mcbe::Transport
 {
 public:
     explicit RaknetTransport(RakNet::RakPeerInterface* peer) : peer(peer)
@@ -17,3 +20,4 @@ public:
 private:
     RakNet::RakPeerInterface* peer = nullptr;
 };
+} // namespace cyrex::network::raknet
\ No newline at end of file
diff --git a/src/network/session/network_session.cpp b/src/network/session/network_session.cpp
index faaecfd..96ea992 100644
--- a/src/network/session/network_session.cpp
+++ b/src/network/session/network_session.cpp
@@ -1,17 +1,21 @@
 ﻿#include "network_session.hpp"
 
+#include "network/mcbe/handler/session_begin_handler.hpp"
 #include "network/mcbe/protocol/network_settings.hpp"
+#include "network/mcbe/protocol/play_status.hpp"
 #include "network/mcbe/protocol/protocol_info.hpp"
 #include "network/util/binary_stream.hpp"
 #include "util/textformat.hpp"
-#include "network/mcbe/protocol/play_status.hpp"
-#include "network/mcbe/handler/session_begin_handler.hpp"
 
 #include <iomanip>
 #include <iostream>
 #include <sstream>
 #include <vector>
-using namespace util::textformat;
+using namespace cyrex::util;
+using namespace cyrex::network::util;
+
+namespace cyrex::network::session
+{
 
 void NetworkSession::onRaw(RakNet::Packet, const uint8_t* data, size_t len)
 {
@@ -27,7 +31,7 @@ void NetworkSession::onRaw(RakNet::Packet, const uint8_t* data, size_t len)
               << renderConsole(bedrock(Color::DARK_GRAY) + " packet id = 0x", false) << std::hex << packetId << std::dec
               << std::endl;
 
-    auto packet = PacketPool::instance().create(packetId);
+    auto packet = cyrex::network::mcbe::PacketPool::instance().create(packetId);
     if (!packet)
     {
         std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
@@ -55,24 +59,25 @@ static std::string hexDump(const uint8_t* data, size_t len)
 }
 
 // TODO: give better name
-bool NetworkSession::disconnectUserForIncompatiableProtocol(uint32_t protocolVersion) 
+bool NetworkSession::disconnectUserForIncompatiableProtocol(uint32_t protocolVersion)
 {
-    PlayStatusPacket packet{};
-    packet.status = protocolVersion < ProtocolInfo::CURRENT_PROTOCOL
-                        ? PlayStatusPacket::LOGIN_FAILED_CLIENT
-                        : PlayStatusPacket::LOGIN_FAILED_SERVER;
+    cyrex::network::mcbe::protocol::PlayStatusPacket packet{};
+    packet.status = protocolVersion < cyrex::network::mcbe::protocol::ProtocolInfo::CURRENT_PROTOCOL
+                        ? cyrex::network::mcbe::protocol::PlayStatusPacket::LOGIN_FAILED_CLIENT
+                        : cyrex::network::mcbe::protocol::PlayStatusPacket::LOGIN_FAILED_SERVER;
     send(packet);
     return true;
 }
 
-void NetworkSession::send(PacketBase& packet)
+void NetworkSession::send(cyrex::network::mcbe::PacketBase& packet)
 {
-    if (PacketPool::instance().direction(packet.networkId()) == PacketDirection::Serverbound)
+    if (cyrex::network::mcbe::PacketPool::instance().direction(packet.networkId()) ==
+        cyrex::network::mcbe::PacketDirection::Serverbound)
     {
         return;
     }
 
-    BinaryStream payload;
+    cyrex::network::util::BinaryStream payload;
     packet.encode(payload);
 
     std::vector<uint8_t> out;
@@ -120,14 +125,15 @@ void NetworkSession::send(PacketBase& packet)
     m_transport->send(m_guid, out.data(), out.size());
 }
 
-void NetworkSession::setCompressor(std::unique_ptr<Compressor> comp)
+void NetworkSession::setCompressor(std::unique_ptr<cyrex::network::mcbe::compression::Compressor> comp)
 {
     m_compressor = std::move(comp);
 }
 
-bool NetworkSession::handleRequestNetworkSettings(PacketBase& packet)
+bool NetworkSession::handleRequestNetworkSettings(cyrex::network::mcbe::PacketBase& packet)
 {
-    SessionBeginHandler handler{};
+    cyrex::network::mcbe::handler::SessionBeginHandler handler{};
     handler.handle(*this, packet);
     return true;
-}
\ No newline at end of file
+}
+} // namespace cyrex::network::session
\ No newline at end of file
diff --git a/src/network/session/network_session.hpp b/src/network/session/network_session.hpp
index f18df9b..78893ad 100644
--- a/src/network/session/network_session.hpp
+++ b/src/network/session/network_session.hpp
@@ -5,6 +5,7 @@
 #include "network/mcbe/compression/zlib_compressor.hpp"
 #include "network/mcbe/packet.hpp"
 #include "network/mcbe/packet_pool.hpp"
+#include "network/mcbe/packetbase.hpp"
 #include "network/mcbe/transport.hpp"
 #include "network/util/binary_stream.hpp"
 
@@ -13,6 +14,9 @@
 
 #include <cstdint>
 
+namespace cyrex::network::session
+{
+
 enum class Phase
 {
     HANDSHAKE,
@@ -22,12 +26,12 @@ enum class Phase
 class NetworkSession
 {
 public:
-    NetworkSession(RakNet::RakNetGUID guid, RakNet::SystemAddress address, Transport* transport) :
+    NetworkSession(RakNet::RakNetGUID guid, RakNet::SystemAddress address, cyrex::network::mcbe::Transport* transport) :
         m_guid(guid),
         m_address(address),
         m_transport(transport),
         m_protocolId(0),
-        m_compressor(std::make_unique<NoopCompressor>())
+        m_compressor(std::make_unique<cyrex::network::mcbe::compression::NoopCompressor>())
     {
     }
 
@@ -35,13 +39,13 @@ public:
     Phase phase = Phase::HANDSHAKE;
 
     void onRaw(RakNet::Packet packet, const uint8_t* data, size_t len);
-    void send(PacketBase& packet);
+    void send(cyrex::network::mcbe::PacketBase& packet);
     bool disconnectUserForIncompatiableProtocol(uint32_t);
-    bool handleRequestNetworkSettings(PacketBase& packet);
+    bool handleRequestNetworkSettings(cyrex::network::mcbe::PacketBase& packet);
 
-    void setCompressor(std::unique_ptr<Compressor> compressor);
+    void setCompressor(std::unique_ptr<cyrex::network::mcbe::compression::Compressor> compressor);
 
-    Compressor& compressor() const
+    cyrex::network::mcbe::compression::Compressor& compressor() const
     {
         return *m_compressor;
     }
@@ -69,8 +73,9 @@ public:
 private:
     RakNet::RakNetGUID m_guid;
     RakNet::SystemAddress m_address;
-    Transport* m_transport;
+    cyrex::network::mcbe::Transport* m_transport;
 
     std::uint32_t m_protocolId;
-    std::unique_ptr<Compressor> m_compressor;
+    std::unique_ptr<cyrex::network::mcbe::compression::Compressor> m_compressor;
 };
+} // namespace cyrex::network::session
\ No newline at end of file
diff --git a/src/network/util/binary_stream.hpp b/src/network/util/binary_stream.hpp
index 4726dd1..344798a 100644
--- a/src/network/util/binary_stream.hpp
+++ b/src/network/util/binary_stream.hpp
@@ -10,6 +10,9 @@
 #include <cstdint>
 #include <cstring>
 
+namespace cyrex::network::util
+{
+
 class BinaryStream
 {
 public:
@@ -179,12 +182,12 @@ public:
         return s;
     }
 
-    Vector2 readVector2()
+    cyrex::math::Vector2 readVector2()
     {
         return {readFloatLE(), readFloatLE()};
     }
 
-    Vector3 readVector3()
+    cyrex::math::Vector3 readVector3()
     {
         return {readFloatLE(), readFloatLE(), readFloatLE()};
     }
@@ -281,7 +284,7 @@ public:
                 break;
             }
         }
-    } 
+    }
 
     void writeVarInt(int32_t v)
     {
@@ -332,3 +335,5 @@ private:
             throw std::runtime_error("BinaryStream overflow");
     }
 };
+
+} // namespace cyrex::network::util
\ No newline at end of file
diff --git a/src/raknet_peer.cpp b/src/raknet_peer.cpp
index 401ab9c..5c15a4c 100644
--- a/src/raknet_peer.cpp
+++ b/src/raknet_peer.cpp
@@ -1,5 +1,7 @@
 #include "raknet_peer.hpp"
 
+// Duplicate raknet peer, we will need to implement this in our other one
+
 #include <stdexcept>
 
 cyrex::RakNetPeer::RakNetPeer(RakNet::RakPeerInterface* peerInterface) : m_peerInterface(peerInterface)
diff --git a/src/util/performance.cpp b/src/util/performance.cpp
index 18d9a14..d085a5c 100644
--- a/src/util/performance.cpp
+++ b/src/util/performance.cpp
@@ -6,12 +6,10 @@
 #include <sstream>
 #include <thread>
 
-namespace util::performance
+namespace cyrex::util
 {
 std::string getReport()
 {
-    using namespace util::textformat;
-
     static auto startTime = std::chrono::steady_clock::now();
     auto now = std::chrono::steady_clock::now();
 
@@ -38,4 +36,4 @@ std::string getReport()
 
     return out.str();
 }
-} // namespace util::performance
+} // namespace cyrex::util
diff --git a/src/util/performance.hpp b/src/util/performance.hpp
index d5b797a..134fced 100644
--- a/src/util/performance.hpp
+++ b/src/util/performance.hpp
@@ -2,7 +2,7 @@
 
 #include <string>
 
-namespace util::performance
+namespace cyrex::util
 {
 std::string getReport();
 }
diff --git a/src/util/server_properties.cpp b/src/util/server_properties.cpp
index ab30da2..a9ea78e 100644
--- a/src/util/server_properties.cpp
+++ b/src/util/server_properties.cpp
@@ -3,7 +3,9 @@
 #include <filesystem>
 #include <fstream>
 #include <sstream>
-#include <unordered_map>
+
+namespace cyrex::util
+{
 
 static ServerProperties defaults()
 {
@@ -12,7 +14,10 @@ static ServerProperties defaults()
 
 static void writeDefaults(const std::string& path, const ServerProperties& cfg)
 {
-    std::ofstream out(path);
+    std::ofstream out(path, std::ios::trunc);
+    if (!out.is_open())
+        return;
+
     out << "server-port=" << cfg.port << "\n";
     out << "server-portv6=" << cfg.portIpv6 << "\n";
     out << "max-players=" << cfg.maxPlayers << "\n";
@@ -32,8 +37,11 @@ ServerProperties ServerProperties::load(const std::string& path)
 
     auto cfg = defaults();
     std::ifstream in(path);
-    std::string line;
 
+    if (!in.is_open())s
+        return cfg;
+
+    std::string line;
     while (std::getline(in, line))
     {
         if (line.empty() || line[0] == '#')
@@ -43,15 +51,15 @@ ServerProperties ServerProperties::load(const std::string& path)
         if (pos == std::string::npos)
             continue;
 
-        std::string key = line.substr(0, pos);
-        std::string val = line.substr(pos + 1);
+        const std::string key = line.substr(0, pos);
+        const std::string val = line.substr(pos + 1);
 
         if (key == "server-port")
             cfg.port = static_cast<std::uint16_t>(std::stoi(val));
         else if (key == "server-portv6")
             cfg.portIpv6 = static_cast<std::uint16_t>(std::stoi(val));
         else if (key == "max-players")
-            cfg.maxPlayers = static_cast<std::uint32_t>(std::stoi(val));
+            cfg.maxPlayers = static_cast<std::uint32_t>(std::stoul(val));
         else if (key == "server-name")
             cfg.serverName = val;
         else if (key == "motd")
@@ -62,3 +70,5 @@ ServerProperties ServerProperties::load(const std::string& path)
 
     return cfg;
 }
+
+} // namespace cyrex::util
diff --git a/src/util/server_properties.hpp b/src/util/server_properties.hpp
index 3a5243a..e2a514f 100644
--- a/src/util/server_properties.hpp
+++ b/src/util/server_properties.hpp
@@ -6,6 +6,9 @@
 
 #include <cstdint>
 
+namespace cyrex::util
+{
+
 struct ServerProperties
 {
     std::uint16_t port;
@@ -17,3 +20,5 @@ struct ServerProperties
 
     static ServerProperties load(const std::string& path);
 };
+
+} // namespace cyrex::util
\ No newline at end of file
diff --git a/src/util/textformat.hpp b/src/util/textformat.hpp
index bc7573a..0a0ffd6 100644
--- a/src/util/textformat.hpp
+++ b/src/util/textformat.hpp
@@ -1,17 +1,16 @@
 #pragma once
 
-#include <string>
-#include <string_view>
-#include <unordered_map>
-
 #include <chrono>
 #include <iomanip>
 #include <sstream>
+#include <string>
+#include <string_view>
+#include <unordered_map>
 
-namespace util::textformat
+namespace cyrex::util
 {
 // should make sure this is proper
-inline constexpr char CODE = '\xA7';
+constexpr char CODE = '\xA7';
 
 enum class Color : char
 {
@@ -158,4 +157,4 @@ inline std::string renderConsole(std::string_view text, bool includeTime)
     out += "\033[0m";
     return out;
 }
-} // namespace util::textformat
+} // namespace cyrex::util
diff --git a/tests/server.cpp b/tests/server.cpp
index 2934a83..1df6f55 100644
--- a/tests/server.cpp
+++ b/tests/server.cpp
@@ -1,94 +1,95 @@
-#include <gtest/gtest.h>
-
-#include <server.hpp>
-
-struct cyrex::Server::Testing
-{
-    static void onNullPacketReceived(Server& server)
-    {
-        server.onPacketReceived(nullptr);
-    }
-};
-
-class MockPeer : public cyrex::INetworkPeer
-{
-public:
-    [[nodiscard]] cyrex::StartupResult startup(const StartupInfo startupInfo) override
-    {
-        (void)startupInfo;
-        return cyrex::StartupResult::RAKNET_ALREADY_STARTED;
-    }
-
-    void shutdown(const ShutdownInfo shutdownInfo) override
-    {
-        (void)shutdownInfo;
-    }
-
-    [[nodiscard]] cyrex::Packet* receive() override
-    {
-        return nullptr;
-    }
-
-    [[nodiscard]] std::uint32_t send(const char* data, const std::uint32_t length, const SendInfo sendInfo) override
-    {
-        (void)data;
-        (void)length;
-        (void)sendInfo;
-        return 0;
-    }
-
-    void setMaximumIncomingConnections(const std::uint16_t maxIncomingConnections) override
-    {
-        (void)maxIncomingConnections;
-    }
-
-    void deallocatePacket(cyrex::Packet* packet) override
-    {
-        (void)packet;
-    }
-
-    [[nodiscard]] bool isActive() const override
-    {
-        return false;
-    }
-};
-
-// --- TEST SUITE 1 ---
-TEST(ServerTest, ConstructorThrowsOnNullPeer)
-{
-    ASSERT_THROW(cyrex::Server(nullptr, {}), cyrex::Server::InitFailedError);
-}
-
-TEST(ServerTest, ConstructorThrowsOnInvalidConfig)
-{
-    const cyrex::Server::Config badMaxUsers{
-        .port = 1234,
-        .maxUsers = 0,
-        .maxIncomingConnections = 10,
-    };
-
-    const cyrex::Server::Config badIncomingConnections{
-        .port = 1234,
-        .maxUsers = 20,
-        .maxIncomingConnections = 0,
-    };
-
-    auto mockPeerA = MockPeer{};
-    auto mockPeerB = MockPeer{};
-
-    ASSERT_THROW(cyrex::Server(&mockPeerA, badMaxUsers), cyrex::Server::InitFailedError);
-    ASSERT_THROW(cyrex::Server(&mockPeerB, badIncomingConnections), cyrex::Server::InitFailedError);
-}
-
-TEST(ServerTest, OnPacketReceivedThrowsNullPacketException)
-{
-    const cyrex::Server::Config cfg{
-        .port = 1234,
-        .maxUsers = 10,
-        .maxIncomingConnections = 10,
-    };
-
-    auto peer = MockPeer{};
-    cyrex::Server server(&peer, cfg);
-    ASSERT_THROW(cyrex::Server::Testing::onNullPacketReceived(server), cyrex::Server::NullPacketException);
-}
+// Glalie: redo
+//#include <gtest/gtest.h>
+//
+//#include <server.hpp>
+//
+//struct cyrex::Server::Testing
+//{
+//    static void onNullPacketReceived(Server& server)
+//    {
+//        server.onPacketReceived(nullptr);
+//    }
+//};
+//
+//class MockPeer : public cyrex::INetworkPeer
+//{
+//public:
+//    [[nodiscard]] cyrex::StartupResult startup(const StartupInfo startupInfo) override
+//    {
+//        (void)startupInfo;
+//        return cyrex::StartupResult::RAKNET_ALREADY_STARTED;
+//    }
+//
+//    void shutdown(const ShutdownInfo shutdownInfo) override
+//    {
+//        (void)shutdownInfo;
+//    }
+//
+//    [[nodiscard]] cyrex::Packet* receive() override
+//    {
+//        return nullptr;
+//    }
+//
+//    [[nodiscard]] std::uint32_t send(const char* data, const std::uint32_t length, const SendInfo sendInfo) override
+//    {
+//        (void)data;
+//        (void)length;
+//        (void)sendInfo;
+//        return 0;
+//    }
+//
+//    void setMaximumIncomingConnections(const std::uint16_t maxIncomingConnections) override
+//    {
+//        (void)maxIncomingConnections;
+//    }
+//
+//    void deallocatePacket(cyrex::Packet* packet) override
+//    {
+//        (void)packet;
+//    }
+//
+//    [[nodiscard]] bool isActive() const override
+//    {
+//        return false;
+//    }
+//};
+//
+//// --- TEST SUITE 1 ---
+//TEST(ServerTest, ConstructorThrowsOnNullPeer)
+//{
+//    ASSERT_THROW(cyrex::Server(nullptr, {}), cyrex::Server::InitFailedError);
+//}
+//
+//TEST(ServerTest, ConstructorThrowsOnInvalidConfig)
+//{
+//    const cyrex::Server::Config badMaxUsers{
+//        .port = 1234,
+//        .maxUsers = 0,
+//        .maxIncomingConnections = 10,
+//    };
+//
+//    const cyrex::Server::Config badIncomingConnections{
+//        .port = 1234,
+//        .maxUsers = 20,
+//        .maxIncomingConnections = 0,
+//    };
+//
+//    auto mockPeerA = MockPeer{};
+//    auto mockPeerB = MockPeer{};
+//
+//    ASSERT_THROW(cyrex::Server(&mockPeerA, badMaxUsers), cyrex::Server::InitFailedError);
+//    ASSERT_THROW(cyrex::Server(&mockPeerB, badIncomingConnections), cyrex::Server::InitFailedError);
+//}
+//
+//TEST(ServerTest, OnPacketReceivedThrowsNullPacketException)
+//{
+//    const cyrex::Server::Config cfg{
+//        .port = 1234,
+//        .maxUsers = 10,
+//        .maxIncomingConnections = 10,
+//    };
+//
+//    auto peer = MockPeer{};
+//    cyrex::Server server(&peer, cfg);
+//    ASSERT_THROW(cyrex::Server::Testing::onNullPacketReceived(server), cyrex::Server::NullPacketException);
+//}
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..e69de29
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5e42aa9..553c8dd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,11 +1,10 @@
-cmake_minimum_required(VERSION 3.15)
-
-include(FetchContent)
+﻿cmake_minimum_required(VERSION 3.15)
 
 project(CyrexMC VERSION 1.0 LANGUAGES CXX)
+
+include(FetchContent)
 enable_testing()
 
-# define a macro that helps defining an option
 macro(CyrexMC_set_option var default type docstring)
     if(NOT DEFINED ${var})
         set(${var} ${default})
@@ -13,15 +12,16 @@ macro(CyrexMC_set_option var default type docstring)
     set(${var} ${${var}} CACHE ${type} ${docstring} FORCE)
 endmacro()
 
-
 if(ENABLE_SANITIZERS)
-    string(APPEND CMAKE_CXX_FLAGS " -fno-omit-frame-pointer -fno-sanitize-recover=all -fsanitize=undefined")
+    string(APPEND CMAKE_CXX_FLAGS
+        " -fno-omit-frame-pointer -fno-sanitize-recover=all -fsanitize=undefined")
 endif()
 
 FetchContent_Declare(RakNet
-    SYSTEM 
+    SYSTEM
     GIT_REPOSITORY https://github.com/CyrexWare/RakNet
-    GIT_TAG 700207323fe306ec6154371b866360cbbf058afe)
+    GIT_TAG 700207323fe306ec6154371b866360cbbf058afe
+)
 FetchContent_MakeAvailable(RakNet)
 
 FetchContent_Declare(
@@ -29,43 +29,79 @@ FetchContent_Declare(
     GIT_REPOSITORY https://github.com/google/googletest.git
     GIT_TAG v1.14.0
 )
-
 set(BUILD_MOCK ON CACHE BOOL "" FORCE)
 FetchContent_MakeAvailable(googletest)
 
 FetchContent_Declare(MagicEnum
-    SYSTEM 
+    SYSTEM
     GIT_REPOSITORY https://github.com/Neargye/magic_enum
-    GIT_TAG v0.9.7)
+    GIT_TAG v0.9.7
+)
 FetchContent_MakeAvailable(MagicEnum)
 
-file(GLOB_RECURSE SRC_FILES "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/*.hpp")
+FetchContent_Declare(libdeflate
+    SYSTEM
+    GIT_REPOSITORY https://github.com/ebiggers/libdeflate.git
+    GIT_TAG v1.19
+)
+FetchContent_MakeAvailable(libdeflate)
+
+file(GLOB_RECURSE ENGINE_SOURCES CONFIGURE_DEPENDS
+    "${PROJECT_SOURCE_DIR}/src/*.cpp"
+    "${PROJECT_SOURCE_DIR}/src/*/*.cpp"
+    "${PROJECT_SOURCE_DIR}/src/*/*/*.cpp"
+    "${PROJECT_SOURCE_DIR}/server/*.cpp"
+    "${PROJECT_SOURCE_DIR}/server/*/*.cpp"
+)
 
-#
-# We compile CyrexMC_lib and link CyrexMC 
-#
-add_library(CyrexMC_lib STATIC ${SRC_FILES})
-target_compile_features(CyrexMC_lib PUBLIC cxx_std_23)
-target_include_directories(CyrexMC_lib PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/src/")
-target_link_libraries(CyrexMC_lib PUBLIC raknet magic_enum::magic_enum)
+list(FILTER ENGINE_SOURCES EXCLUDE REGEX ".*/server/main\\.cpp$")
 
-CyrexMC_set_option(CLANG_TIDY_EXECUTABLE clang-tidy STRING "Override clang-tidy executable, requires minimum version 14")
-add_custom_target(tidy
-    COMMAND ${CMAKE_COMMAND} -DCLANG_TIDY_EXECUTABLE=${CLANG_TIDY_EXECUTABLE} -DPROJECT_BINARY_DIR=${PROJECT_BINARY_DIR} -P ./cmake/Tidy.cmake
-    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} VERBATIM)
-    
-file(GLOB_RECURSE SERVER_FILES "${CMAKE_CURRENT_SOURCE_DIR}/server/*.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/server/*.hpp")
+add_executable(CyrexMC
+    server/main.cpp
+    ${ENGINE_SOURCES}
+)
 
-add_executable(CyrexMC "${SERVER_FILES}")
-target_link_libraries(CyrexMC PRIVATE CyrexMC_lib)
+target_compile_features(CyrexMC PRIVATE cxx_std_23)
 
-# --- TESTING ---
-file(GLOB_RECURSE TEST_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/tests/*.cpp")
+target_include_directories(CyrexMC PRIVATE
+    "${PROJECT_SOURCE_DIR}/src"
+    "${PROJECT_SOURCE_DIR}/server"
+)
+
+target_link_libraries(CyrexMC PRIVATE
+    raknet
+    magic_enum::magic_enum
+    libdeflate_static
+)
+
+CyrexMC_set_option(
+    CLANG_TIDY_EXECUTABLE
+    clang-tidy
+    STRING
+    "Override clang-tidy executable, requires minimum version 14"
+)
+
+add_custom_target(tidy
+    COMMAND ${CMAKE_COMMAND}
+        -DCLANG_TIDY_EXECUTABLE=${CLANG_TIDY_EXECUTABLE}
+        -DPROJECT_BINARY_DIR=${PROJECT_BINARY_DIR}
+        -P ./cmake/Tidy.cmake
+    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
+    VERBATIM
+)
+
+file(GLOB_RECURSE TEST_SOURCES
+    "${PROJECT_SOURCE_DIR}/tests/*.cpp"
+)
 
 add_executable(RunTests ${TEST_SOURCES})
-target_include_directories(RunTests PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/tests/" )
-target_link_libraries(RunTests PUBLIC  GTest::gtest_main  GTest::gmock_main CyrexMC_lib)
 
-# Auto discover TEST macros
+target_include_directories(RunTests PUBLIC "${PROJECT_SOURCE_DIR}/tests")
+
+target_link_libraries(RunTests PUBLIC
+    GTest::gtest_main
+    GTest::gmock_main
+)
+
 include(GoogleTest)
 gtest_discover_tests(RunTests)
diff --git a/README.md b/README.md
index 63a9ec5..16f2f97 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-# Cyrex Minecraft Server Software
\ No newline at end of file
+# Cyrex MCBE: Server Software
diff --git a/SERVER_START_DOC.md b/SERVER_START_DOC.md
index 3a906c0..88ae0bc 100644
--- a/SERVER_START_DOC.md
+++ b/SERVER_START_DOC.md
@@ -321,4 +321,4 @@ This document is **not exhaustive**, but it covers the **critical packet flow**
 * Sync worlds and inventories
 * Handle modern server‑authoritative movement
 
-Perfect as a starting reference for **custom servers, proxies, or protocol experiments**.
+Perfect as a starting reference for **custom servers, proxies, or protocol experiments**.
\ No newline at end of file
diff --git a/server/main.cpp b/server/main.cpp
index e73ce1c..ff20070 100644
--- a/server/main.cpp
+++ b/server/main.cpp
@@ -1,79 +1,110 @@
-// STD
-#include <iostream>
-// RakNet
-#include <RakNet/MessageIdentifiers.h>
-#include <RakNet/RakPeerInterface.h>
-#include <RakNet/RakSleep.h>
-// Cyrex
-#include "raknet_peer.hpp"
+#include "network/mcbe/packet_pool.hpp"
 #include "server.hpp"
+#include "util/server_properties.hpp"
+#include "util/textformat.hpp"
+
+#include <filesystem>
+#include <fstream>
+#include <iostream>
+
+#include <csignal>
+
+#if defined(_WIN32)
+#include <windows.h>
+#else
+#include <signal.h>
+#include <unistd.h>
+#endif
 
 namespace
 {
-void debugClient()
-{
-    RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();
 
-    if (peer == nullptr)
-    {
-        return;
-    }
+static std::filesystem::path lockFile = "server.lock";
 
-    bool active = true;
-    RakNet::SocketDescriptor socketDescriptor;
-    peer->Startup(1, &socketDescriptor, 1);
-    peer->Connect("127.0.0.1", 19132, nullptr, 0);
+static uint64_t getPid()
+{
+#if defined(_WIN32)
+    return static_cast<uint64_t>(GetCurrentProcessId());
+#else
+    return static_cast<uint64_t>(getpid());
+#endif
+}
 
-    while (active)
-    {
-        for (RakNet::Packet* packet{}; (packet = peer->Receive()) != nullptr; peer->DeallocatePacket(packet))
-        {
-            switch (packet->data[0])
-            {
-                case ID_CONNECTION_REQUEST_ACCEPTED:
-                    std::cerr << "client connected to server\n";
-                    break;
-                case ID_CONNECTION_ATTEMPT_FAILED:
-                    std::cerr << "failed to connect to the server\n";
-                    active = false;
-                    break;
-            }
-            if (!active)
-                break;
-        }
-        RakSleep(10);
-    }
+static bool isProcessAlive(uint64_t pid)
+{
+#if defined(_WIN32)
+    HANDLE h = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, static_cast<DWORD>(pid));
+    if (!h)
+        return false;
+    DWORD code = 0;
+    bool alive = GetExitCodeProcess(h, &code) && code == STILL_ACTIVE;
+    CloseHandle(h);
+    return alive;
+#else
+    return kill(static_cast<pid_t>(pid), 0) == 0;
+#endif
+}
 
-    peer->Shutdown(50);
+static void removeLock()
+{
+    std::error_code ec;
+    std::filesystem::remove(lockFile, ec);
 }
 
+static void onExit()
+{
+    removeLock();
+}
 
-void server()
+static void onSignal(int)
 {
-    try
-    {
-        cyrex::RakNetPeer rakPeer(RakNet::RakPeerInterface::GetInstance());
-        cyrex::Server server(&rakPeer, cyrex::Server::Config::makeDefault());
-        server.run();
-    } catch (const cyrex::Server::InitFailedError& initFailedError)
-    {
-        std::cerr << "Server Initialization Failed: " << initFailedError.what() << '\n';
-    }
+    removeLock();
+    std::_Exit(0);
 }
 } // namespace
 
 int main()
 {
-    puts("[c]lient / [s]erver");
-    const std::int32_t ch = getchar();
-    if (ch == 'c')
+    using namespace cyrex::util;
+
+    if (std::filesystem::exists(lockFile))
     {
-        debugClient();
+        uint64_t pid = 0;
+        std::ifstream in(lockFile);
+        in >> pid;
+
+        if (pid != 0 && isProcessAlive(pid))
+        {
+            std::string msg;
+            msg += bedrock(Color::RED) + "Another instance of the server is already running.\n";
+            msg += bedrock(Color::GRAY) + "Press ENTER to safely close this instance.";
+
+            std::cout << renderConsole(msg, true) << std::endl;
+            std::cin.get();
+            return 1;
+        }
+
+        removeLock();
     }
-    else if (ch == 's')
+
     {
-        server();
+        std::ofstream out(lockFile, std::ios::trunc);
+        out << getPid();
     }
 
+    std::atexit(onExit);
+    std::signal(SIGINT, onSignal);
+    std::signal(SIGTERM, onSignal);
+
+#if !defined(_WIN32)
+    std::signal(SIGHUP, onSignal);
+#endif
+
+    auto props = cyrex::util::ServerProperties::load("server.properties");
+    cyrex::Server server(cyrex::Server::Config::fromProperties(props));
+    cyrex::network::mcbe::PacketPool::instance().registerAll();
+    server.run();
+
+    removeLock();
     return 0;
-}
+}
\ No newline at end of file
diff --git a/src/actor/actor.cpp b/src/actor/actor.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/actor/actor.hpp b/src/actor/actor.hpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/actor/living.cpp b/src/actor/living.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/actor/living.hpp b/src/actor/living.hpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/auto_fix_encoding.py b/src/auto_fix_encoding.py
new file mode 100644
index 0000000..02f8a04
--- /dev/null
+++ b/src/auto_fix_encoding.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+import os
+import sys
+from pathlib import Path
+
+TEXT_EXTENSIONS = {
+    ".c", ".cpp", ".h", ".hpp", ".inl",
+    ".py", ".cmake", ".txt", ".md",
+    ".json", ".yml", ".yaml",
+    ".sh", ".bat"
+}
+
+def is_probably_text(path: Path) -> bool:
+    return path.suffix.lower() in TEXT_EXTENSIONS
+
+def fix_file(path: Path):
+    try:
+        raw = path.read_bytes()
+    except Exception:
+        return
+
+    if b"\x00" in raw[:1024] and path.suffix.lower() not in TEXT_EXTENSIONS:
+        return
+
+    encodings = ["utf-8", "utf-16", "utf-16-le", "utf-16-be", "utf-32"]
+
+    text = None
+    used_encoding = None
+
+    for enc in encodings:
+        try:
+            text = raw.decode(enc)
+            used_encoding = enc
+            break
+        except UnicodeDecodeError:
+            continue
+
+    if text is None:
+        return
+
+    cleaned = text.replace("\x00", "")
+
+    if used_encoding != "utf-8" or cleaned != text:
+        path.write_text(cleaned, encoding="utf-8", newline="\n")
+        print(f"[FIXED] {path} ({used_encoding} → utf-8)")
+
+def walk(root: Path):
+    for p in root.rglob("*"):
+        if p.is_file() and is_probably_text(p):
+            fix_file(p)
+
+if __name__ == "__main__":
+    root = Path(sys.argv[1]) if len(sys.argv) > 1 else Path(".")
+    print(f"Scanning: {root.resolve()}")
+    walk(root)
+    print("Done.")
diff --git a/src/command/command_base.hpp b/src/command/command_base.hpp
new file mode 100644
index 0000000..41b83a4
--- /dev/null
+++ b/src/command/command_base.hpp
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "command_context.hpp"
+#include "permission.hpp"
+
+#include <string>
+#include <vector>
+
+class CommandBase
+{
+public:
+    virtual ~CommandBase() = default;
+
+    virtual std::string name() const = 0;
+    virtual std::vector<std::string> aliases() const
+    {
+        return {};
+    }
+    virtual std::string description() const = 0;
+
+    virtual Permission permission() const = 0;
+
+    virtual void execute(const CommandContext& ctx) = 0;
+};
diff --git a/src/command/command_context.hpp b/src/command/command_context.hpp
new file mode 100644
index 0000000..c270ee7
--- /dev/null
+++ b/src/command/command_context.hpp
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "permission.hpp"
+
+#include <string>
+#include <vector>
+
+class Server;
+
+struct CommandContext
+{
+    Server& server;
+    std::string raw;
+    std::vector<std::string> args;
+
+    PermissionLevel sourceLevel;
+};
diff --git a/src/command/command_manager.cpp b/src/command/command_manager.cpp
new file mode 100644
index 0000000..c9dedec
--- /dev/null
+++ b/src/command/command_manager.cpp
@@ -0,0 +1,71 @@
+#include "command_context.hpp"
+#include "command_manager.hpp"
+#include "command/types/performance_command.hpp"
+#include "command/types/stop_command.hpp"
+#include "server.hpp"
+#include "util/textformat.hpp"
+
+#include <iostream>
+#include <sstream>
+
+CommandManager::CommandManager(Server& server) : m_server(server)
+{
+}
+
+void CommandManager::registerDefaults()
+{
+    registerCommand(std::make_unique<StopCommand>());
+    registerCommand(std::make_unique<PerformanceCommand>());
+}
+
+void CommandManager::registerCommand(std::unique_ptr<CommandBase> command)
+{
+    m_registry.registerCommand(std::move(command));
+}
+
+bool CommandManager::hasPermission(PermissionLevel source, const Permission& required) const
+{
+    return static_cast<int>(source) >= static_cast<int>(required.level);
+}
+
+void CommandManager::executeConsole(const std::string& line)
+{
+    std::istringstream ss(line);
+    std::string name;
+    ss >> name;
+
+    if (name.empty())
+        return;
+
+    std::vector<std::string> args;
+    std::string arg;
+    while (ss >> arg)
+        args.push_back(arg);
+
+    auto* cmd = m_registry.find(name);
+    if (!cmd)
+    {
+        std::cout << util::textformat::renderConsole(
+                         util::textformat::bedrock(util::textformat::Color::RED) +
+                         util::textformat::bedrock(util::textformat::Style::BOLD) + "[Cyrex] The command you have entered does not exist, make sure the spelling is correct." +
+                         util::textformat::bedrock(util::textformat::Style::RESET), false)
+                  << std::endl;
+        return;
+    }
+
+    PermissionLevel sourceLevel = PermissionLevel::CONSOLE;
+
+    if (!hasPermission(sourceLevel, cmd->permission()))
+    {
+        std::cout << util::textformat::renderConsole(
+                         util::textformat::bedrock(util::textformat::Color::GOLD) +
+                         util::textformat::bedrock(util::textformat::Style::BOLD) + "[Cyrex] You do not have permission to use this command." +
+                         util::textformat::bedrock(util::textformat::Style::RESET), false)
+                  << std::endl;
+        return;
+    }
+
+    CommandContext ctx{m_server, line, args, sourceLevel};
+
+    cmd->execute(ctx);
+}
diff --git a/src/command/command_manager.hpp b/src/command/command_manager.hpp
new file mode 100644
index 0000000..2c9aafe
--- /dev/null
+++ b/src/command/command_manager.hpp
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "command_registry.hpp"
+#include "permission.hpp"
+
+#include <string>
+
+class Server;
+
+class CommandManager
+{
+public:
+    explicit CommandManager(Server& server);
+
+    void registerDefaults();
+    void registerCommand(std::unique_ptr<CommandBase> command);
+
+    void executeConsole(const std::string& line);
+
+private:
+    bool hasPermission(PermissionLevel source, const Permission& required) const;
+
+    Server& m_server;
+    CommandRegistry m_registry;
+};
diff --git a/src/command/command_registry.cpp b/src/command/command_registry.cpp
new file mode 100644
index 0000000..924fda4
--- /dev/null
+++ b/src/command/command_registry.cpp
@@ -0,0 +1,20 @@
+#include "command_registry.hpp"
+
+void CommandRegistry::registerCommand(std::unique_ptr<CommandBase> command)
+{
+    CommandBase* ptr = command.get();
+
+    m_lookup[ptr->name()] = ptr;
+    for (const auto& alias : ptr->aliases())
+        m_lookup[alias] = ptr;
+
+    m_storage.push_back(std::move(command));
+}
+
+CommandBase* CommandRegistry::find(const std::string& name) const
+{
+    auto it = m_lookup.find(name);
+    if (it == m_lookup.end())
+        return nullptr;
+    return it->second;
+}
diff --git a/src/command/command_registry.hpp b/src/command/command_registry.hpp
new file mode 100644
index 0000000..bb7870c
--- /dev/null
+++ b/src/command/command_registry.hpp
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "command_base.hpp"
+
+#include <memory>
+#include <string>
+#include <unordered_map>
+
+class CommandRegistry
+{
+public:
+    void registerCommand(std::unique_ptr<CommandBase> command);
+    CommandBase* find(const std::string& name) const;
+
+private:
+    std::unordered_map<std::string, CommandBase*> m_lookup;
+    std::vector<std::unique_ptr<CommandBase>> m_storage;
+};
diff --git a/src/command/permission.hpp b/src/command/permission.hpp
new file mode 100644
index 0000000..de9058f
--- /dev/null
+++ b/src/command/permission.hpp
@@ -0,0 +1,16 @@
+#pragma once
+
+#include <string>
+
+enum class PermissionLevel
+{
+    PLAYER = 0,
+    OP = 1,
+    CONSOLE = 2
+};
+
+struct Permission
+{
+    std::string node;
+    PermissionLevel level;
+};
diff --git a/src/command/types/performance_command.cpp b/src/command/types/performance_command.cpp
new file mode 100644
index 0000000..d6ca804
--- /dev/null
+++ b/src/command/types/performance_command.cpp
@@ -0,0 +1,27 @@
+#include "performance_command.hpp"
+#include "util/performance.hpp"
+#include "util/textformat.hpp"
+#include "command/permission.hpp"
+
+#include <iostream>
+
+std::string PerformanceCommand::name() const
+{
+    return "performance";
+}
+
+std::string PerformanceCommand::description() const
+{
+    return "Shows server performance stats";
+}
+
+Permission PerformanceCommand::permission() const
+{
+    return {"server.performance", PermissionLevel::OP};
+}
+
+void PerformanceCommand::execute(const CommandContext&)
+{
+    // TODO: make it so we can see if it was send by console or in-game
+    std::cout << util::textformat::renderConsole(util::performance::getReport(), false) << std::endl;
+}
diff --git a/src/command/types/performance_command.hpp b/src/command/types/performance_command.hpp
new file mode 100644
index 0000000..b4f538e
--- /dev/null
+++ b/src/command/types/performance_command.hpp
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "command/command_base.hpp"
+#include "command/command_context.hpp"
+
+class PerformanceCommand final : public CommandBase
+{
+public:
+    std::string name() const override;
+    std::string description() const override;
+    Permission permission() const override;
+    void execute(const CommandContext& ctx) override;
+};
diff --git a/src/command/types/stop_command.cpp b/src/command/types/stop_command.cpp
new file mode 100644
index 0000000..0b4f440
--- /dev/null
+++ b/src/command/types/stop_command.cpp
@@ -0,0 +1,28 @@
+#include "stop_command.hpp"
+#include "server.hpp"
+
+std::string StopCommand::name() const
+{
+    return "stop";
+}
+
+std::vector<std::string> StopCommand::aliases() const
+{
+    return {"shutdown", "exit"};
+}
+
+std::string StopCommand::description() const
+{
+    return "Stops the server";
+}
+
+Permission StopCommand::permission() const
+{
+    return {"server.stop", PermissionLevel::CONSOLE};
+}
+
+void StopCommand::execute(const CommandContext& ctx)
+{
+    // why does lapinozz want to use this instead of a dedicated function? i mean okay wont question, just let it be lmao
+    ctx.server.~Server();
+}
diff --git a/src/command/types/stop_command.hpp b/src/command/types/stop_command.hpp
new file mode 100644
index 0000000..519dbe5
--- /dev/null
+++ b/src/command/types/stop_command.hpp
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "command/command_base.hpp"
+
+class StopCommand final : public CommandBase
+{
+public:
+    std::string name() const override;
+    std::vector<std::string> aliases() const override;
+    std::string description() const override;
+    Permission permission() const override;
+    void execute(const CommandContext& ctx) override;
+};
diff --git a/src/info.hpp b/src/info.hpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/math/vector2.hpp b/src/math/vector2.hpp
new file mode 100644
index 0000000..c0ee9d3
--- /dev/null
+++ b/src/math/vector2.hpp
@@ -0,0 +1,132 @@
+#pragma once
+
+#include <cmath>
+#include <cstdint>
+
+struct Vector2
+{
+    float x;
+    float y;
+
+    constexpr Vector2() : x(0), y(0)
+    {
+    }
+    constexpr Vector2(float x_, float y_) : x(x_), y(y_)
+    {
+    }
+
+    static constexpr Vector2 zero()
+    {
+        return {0.f, 0.f};
+    }
+    static constexpr Vector2 one()
+    {
+        return {1.f, 1.f};
+    }
+
+    float length() const
+    {
+        return std::sqrt(x * x + y * y);
+    }
+
+    float lengthSquared() const
+    {
+        return x * x + y * y;
+    }
+
+    Vector2 normalized() const
+    {
+        float len = length();
+        if (len == 0.f)
+            return Vector2::zero();
+        return {x / len, y / len};
+    }
+
+    float dot(const Vector2& o) const
+    {
+        return x * o.x + y * o.y;
+    }
+
+    float distance(const Vector2& o) const
+    {
+        return (*this - o).length();
+    }
+
+    float distanceSquared(const Vector2& o) const
+    {
+        return (*this - o).lengthSquared();
+    }
+
+    Vector2 floor() const
+    {
+        return {std::floor(x), std::floor(y)};
+    }
+
+    Vector2 ceil() const
+    {
+        return {std::ceil(x), std::ceil(y)};
+    }
+
+    Vector2 abs() const
+    {
+        return {std::fabs(x), std::fabs(y)};
+    }
+
+    Vector2 operator+(const Vector2& o) const
+    {
+        return {x + o.x, y + o.y};
+    }
+
+    Vector2 operator-(const Vector2& o) const
+    {
+        return {x - o.x, y - o.y};
+    }
+
+    Vector2 operator*(float s) const
+    {
+        return {x * s, y * s};
+    }
+
+    Vector2 operator/(float s) const
+    {
+        return {x / s, y / s};
+    }
+
+    Vector2& operator+=(const Vector2& o)
+    {
+        x += o.x;
+        y += o.y;
+        return *this;
+    }
+
+    Vector2& operator-=(const Vector2& o)
+    {
+        x -= o.x;
+        y -= o.y;
+        return *this;
+    }
+
+    Vector2& operator*=(float s)
+    {
+        x *= s;
+        y *= s;
+        return *this;
+    }
+
+    Vector2& operator/=(float s)
+    {
+        x /= s;
+        y /= s;
+        return *this;
+    }
+
+    bool operator==(const Vector2& o) const
+    {
+        return x == o.x && y == o.y;
+    }
+
+    bool operator!=(const Vector2& o) const
+    {
+        return !(*this == o);
+    }
+};
diff --git a/src/math/vector3.hpp b/src/math/vector3.hpp
new file mode 100644
index 0000000..c6075ad
--- /dev/null
+++ b/src/math/vector3.hpp
@@ -0,0 +1,155 @@
+#pragma once
+
+#include <cmath>
+#include <cstdint>
+
+struct Vector3
+{
+    float x;
+    float y;
+    float z;
+
+    constexpr Vector3() : x(0), y(0), z(0)
+    {
+    }
+    constexpr Vector3(float x_, float y_, float z_) : x(x_), y(y_), z(z_)
+    {
+    }
+
+    static constexpr Vector3 zero()
+    {
+        return {0.f, 0.f, 0.f};
+    }
+    static constexpr Vector3 one()
+    {
+        return {1.f, 1.f, 1.f};
+    }
+    static constexpr Vector3 up()
+    {
+        return {0.f, 1.f, 0.f};
+    }
+    static constexpr Vector3 down()
+    {
+        return {0.f, -1.f, 0.f};
+    }
+
+    float length() const
+    {
+        return std::sqrt(x * x + y * y + z * z);
+    }
+
+    float lengthSquared() const
+    {
+        return x * x + y * y + z * z;
+    }
+
+    Vector3 normalized() const
+    {
+        float len = length();
+        if (len == 0.f)
+            return Vector3::zero();
+        return {x / len, y / len, z / len};
+    }
+
+    float dot(const Vector3& o) const
+    {
+        return x * o.x + y * o.y + z * o.z;
+    }
+
+    Vector3 cross(const Vector3& o) const
+    {
+        return {y * o.z - z * o.y, z * o.x - x * o.z, x * o.y - y * o.x};
+    }
+
+    float distance(const Vector3& o) const
+    {
+        return (*this - o).length();
+    }
+
+    float distanceSquared(const Vector3& o) const
+    {
+        return (*this - o).lengthSquared();
+    }
+
+    Vector3 floor() const
+    {
+        return {std::floor(x), std::floor(y), std::floor(z)};
+    }
+
+    Vector3 ceil() const
+    {
+        return {std::ceil(x), std::ceil(y), std::ceil(z)};
+    }
+
+    Vector3 abs() const
+    {
+        return {std::fabs(x), std::fabs(y), std::fabs(z)};
+    }
+
+    Vector3 lerp(const Vector3& to, float t) const
+    {
+        return {x + (to.x - x) * t, y + (to.y - y) * t, z + (to.z - z) * t};
+    }
+
+    Vector3 operator+(const Vector3& o) const
+    {
+        return {x + o.x, y + o.y, z + o.z};
+    }
+
+    Vector3 operator-(const Vector3& o) const
+    {
+        return {x - o.x, y - o.y, z - o.z};
+    }
+
+    Vector3 operator*(float s) const
+    {
+        return {x * s, y * s, z * s};
+    }
+
+    Vector3 operator/(float s) const
+    {
+        return {x / s, y / s, z / s};
+    }
+
+    Vector3& operator+=(const Vector3& o)
+    {
+        x += o.x;
+        y += o.y;
+        z += o.z;
+        return *this;
+    }
+
+    Vector3& operator-=(const Vector3& o)
+    {
+        x -= o.x;
+        y -= o.y;
+        z -= o.z;
+        return *this;
+    }
+
+    Vector3& operator*=(float s)
+    {
+        x *= s;
+        y *= s;
+        z *= s;
+        return *this;
+    }
+
+    Vector3& operator/=(float s)
+    {
+        x /= s;
+        y /= s;
+        z /= s;
+        return *this;
+    }
+
+    bool operator==(const Vector3& o) const
+    {
+        return x == o.x && y == o.y && z == o.z;
+    }
+
+    bool operator!=(const Vector3& o) const
+    {
+        return !(*this == o);
+    }
+};
diff --git a/src/network/mcbe/compression/compressor.hpp b/src/network/mcbe/compression/compressor.hpp
new file mode 100644
index 0000000..12bd04f
--- /dev/null
+++ b/src/network/mcbe/compression/compressor.hpp
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "network/mcbe/protocol/types/CompressionAlgorithm.hpp"
+
+#include <optional>
+#include <vector>
+
+#include <cstddef>
+#include <cstdint>
+
+class Compressor
+{
+public:
+    virtual ~Compressor() = default;
+
+    virtual bool decompress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) = 0;
+    virtual bool compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) = 0;
+    virtual mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept = 0;
+    virtual std::optional<size_t> compressionThreshold() const noexcept = 0;
+};
diff --git a/src/network/mcbe/compression/noop_compressor.hpp b/src/network/mcbe/compression/noop_compressor.hpp
new file mode 100644
index 0000000..362a76c
--- /dev/null
+++ b/src/network/mcbe/compression/noop_compressor.hpp
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "compressor.hpp"
+
+class NoopCompressor final : public Compressor
+{
+public:
+    bool decompress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) override
+    {
+        output.assign(input, input + inputSize);
+        return true;
+    }
+
+    bool compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) override
+    {
+        output.assign(input, input + inputSize);
+        return true;
+    }
+
+    mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override
+    {
+        return mcpe::protocol::types::CompressionAlgorithm::NONE;
+    }
+
+    std::optional<size_t> compressionThreshold() const noexcept override
+    {
+        return std::nullopt;
+    }
+};
diff --git a/src/network/mcbe/compression/zlib_compressor.cpp b/src/network/mcbe/compression/zlib_compressor.cpp
new file mode 100644
index 0000000..d20885a
--- /dev/null
+++ b/src/network/mcbe/compression/zlib_compressor.cpp
@@ -0,0 +1,67 @@
+#include "zlib_compressor.hpp"
+
+#include <stdexcept>
+
+ZlibCompressor::ZlibCompressor(int level, std::optional<size_t> minSize, size_t maxDecompressionSize) :
+    m_level(level),
+    m_minCompressionSize(minSize),
+    m_maxDecompressionSize(maxDecompressionSize)
+{
+    m_compressor = libdeflate_alloc_compressor(level);
+    m_decompressor = libdeflate_alloc_decompressor();
+
+    if (!m_compressor || !m_decompressor)
+        throw std::runtime_error("Failed to initialize libdeflate");
+}
+
+ZlibCompressor::~ZlibCompressor()
+{
+    libdeflate_free_compressor(m_compressor);
+    libdeflate_free_decompressor(m_decompressor);
+}
+
+bool ZlibCompressor::compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output)
+{
+    bool compressible = !m_minCompressionSize.has_value() || inputSize >= *m_minCompressionSize;
+
+    if (!compressible)
+    {
+        output.assign(input, input + inputSize);
+        return true;
+    }
+
+    size_t bound = libdeflate_deflate_compress_bound(m_compressor, inputSize);
+    output.resize(bound);
+
+    size_t written = libdeflate_deflate_compress(m_compressor, input, inputSize, output.data(), bound);
+
+    if (written == 0)
+        return false;
+
+    output.resize(written);
+    return true;
+}
+
+bool ZlibCompressor::decompress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output)
+{
+    output.resize(m_maxDecompressionSize);
+
+    size_t actualSize = 0;
+    auto res = libdeflate_deflate_decompress(m_decompressor, input, inputSize, output.data(), output.size(), &actualSize);
+
+    if (res != LIBDEFLATE_SUCCESS)
+        return false;
+
+    output.resize(actualSize);
+    return true;
+}
+
+mcpe::protocol::types::CompressionAlgorithm ZlibCompressor::networkId() const noexcept
+{
+    return mcpe::protocol::types::CompressionAlgorithm::ZLIB;
+}
+
+std::optional<size_t> ZlibCompressor::compressionThreshold() const noexcept
+{
+    return m_minCompressionSize;
+}
diff --git a/src/network/mcbe/compression/zlib_compressor.hpp b/src/network/mcbe/compression/zlib_compressor.hpp
new file mode 100644
index 0000000..a46ded5
--- /dev/null
+++ b/src/network/mcbe/compression/zlib_compressor.hpp
@@ -0,0 +1,35 @@
+#pragma once
+
+#include "compressor.hpp"
+
+#include <libdeflate.h>
+
+class ZlibCompressor final : public Compressor
+{
+public:
+    static constexpr int DEFAULT_LEVEL = 7;
+    static constexpr size_t DEFAULT_THRESHOLD = 256;
+    static constexpr size_t DEFAULT_MAX_DECOMPRESSION_SIZE = 8 * 1024 * 1024;
+
+    explicit ZlibCompressor(int level = DEFAULT_LEVEL,
+                            std::optional<size_t> minSize = DEFAULT_THRESHOLD,
+                            size_t maxDecompressionSize = DEFAULT_MAX_DECOMPRESSION_SIZE);
+
+    ~ZlibCompressor() override;
+
+    bool decompress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) override;
+
+    bool compress(const uint8_t* input, size_t inputSize, std::vector<uint8_t>& output) override;
+
+    mcpe::protocol::types::CompressionAlgorithm networkId() const noexcept override;
+
+    std::optional<size_t> compressionThreshold() const noexcept override;
+
+private:
+    int m_level;
+    std::optional<size_t> m_minCompressionSize;
+    size_t m_maxDecompressionSize;
+
+    libdeflate_compressor* m_compressor;
+    libdeflate_decompressor* m_decompressor;
+};
diff --git a/src/network/mcbe/handler/session_begin_handler.hpp b/src/network/mcbe/handler/session_begin_handler.hpp
new file mode 100644
index 0000000..2a3ba21
--- /dev/null
+++ b/src/network/mcbe/handler/session_begin_handler.hpp
@@ -0,0 +1,49 @@
+#pragma once
+
+#include "network/mcbe/protocol/request_network_settings.hpp"
+
+#include<iostream>
+
+// TODO: make an handler base class.
+class SessionBeginHandler
+{
+public:
+    void handle(NetworkSession& session, PacketBase& packet)
+    {
+        // theres no way this is actually good, glalie review this, if this is lwk valid, idc yk
+        auto& pk = static_cast<RequestNetworkSettingsPacket&>(packet);
+        uint32_t version = pk.protocolVersion;
+
+        // no guarentee that a protocol is accepted at the moment
+        // we mabye will support multiple versions or make it easy for plugins to.
+        if (!isProtocolMabyeAccepted(version))
+        {
+            session.disconnectUserForIncompatiableProtocol(version);
+            return;
+        }
+        
+        session.setProtocolId(version);
+
+        // this packet needs to be properly handled and we should call session's compressor networkId, right now this is just hardcoded
+        NetworkSettingsPacket pak{};
+        pak.compressionThreshold = NetworkSettingsPacket::COMPRESS_EVERYTHING;
+        pak.compressionAlgorithm = 1;
+        pak.padding = 00;
+        pak.enableClientThrottling = false;
+        pak.clientThrottleThreshold = 0;
+        pak.clientThrottleScalar = 0.0f;
+        pak.trailingZero = 0;
+        session.send(pak);
+        // mark compression as ready to go lol!
+        session.compressionEnabled = true;
+    }
+
+    // no way im planning multiprotocol??
+    constexpr bool isProtocolMabyeAccepted(std::uint32_t protocol)
+    {
+        for (auto p : ProtocolInfo::ACCEPTED_PROTOCOLS)
+            if (p == protocol)
+                return true;
+        return false;
+    }
+};
diff --git a/src/network/mcbe/mcbe_batch_decoder.cpp b/src/network/mcbe/mcbe_batch_decoder.cpp
new file mode 100644
index 0000000..31e94bb
--- /dev/null
+++ b/src/network/mcbe/mcbe_batch_decoder.cpp
@@ -0,0 +1,40 @@
+﻿#include "mcbe_batch_decoder.hpp"
+
+#include "network/util/binary_stream.hpp"
+
+//TODO: use this again, right now it has no official purpose, in test builds, i worked on, this had a purpose
+// However now no longer, this should be recoded, COMPLETELY, its faulty and dont uses session->compressor.
+bool McbeBatchDecoder::decode(const uint8_t* data, size_t len, std::vector<McbeBatchPacket>& out)
+{
+    if (len < 1)
+        return false;
+
+    BinaryStream in(data, len);
+
+    uint8_t compression = in.readU8();
+
+    // Until NetworkSettingsPacket is exchanged,
+    // MCBE packets are NOT compressed
+    if (compression != 0x00)
+        return false;
+
+    while (in.remaining() > 0)
+    {
+        uint32_t packetLen = in.readVarInt();
+
+        if (packetLen == 0 || packetLen > in.remaining())
+            return false;
+
+        McbeBatchPacket pkt;
+        pkt.data.resize(packetLen);
+
+        for (uint32_t i = 0; i < packetLen; ++i)
+        {
+            pkt.data[i] = in.readU8();
+        }
+
+        out.push_back(std::move(pkt));
+    }
+
+    return true;
+}
diff --git a/src/network/mcbe/mcbe_batch_decoder.hpp b/src/network/mcbe/mcbe_batch_decoder.hpp
new file mode 100644
index 0000000..bfdb354
--- /dev/null
+++ b/src/network/mcbe/mcbe_batch_decoder.hpp
@@ -0,0 +1,17 @@
+#pragma once
+
+#include <vector>
+
+#include <cstddef>
+#include <cstdint>
+
+struct McbeBatchPacket
+{
+    std::vector<uint8_t> data;
+};
+
+class McbeBatchDecoder
+{
+public:
+    static bool decode(const uint8_t* data, size_t len, std::vector<McbeBatchPacket>& outPackets);
+};
diff --git a/src/network/mcbe/packet.hpp b/src/network/mcbe/packet.hpp
new file mode 100644
index 0000000..5e7dd06
--- /dev/null
+++ b/src/network/mcbe/packet.hpp
@@ -0,0 +1,42 @@
+#pragma once
+
+#include "packetbase.hpp"
+#include "network/util/binary_stream.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+
+class Packet : public PacketBase
+{
+public:
+    static constexpr uint32_t ID_MASK = 0x3FF;
+    static constexpr uint32_t SUBCLIENT_MASK = 0x03;
+    static constexpr uint32_t SENDER_SHIFT = 10;
+    static constexpr uint32_t RECIPIENT_SHIFT = 12;
+
+    uint8_t senderSubId = 0;
+    uint8_t recipientSubId = 0;
+
+    void decode(BinaryStream& in) final
+    {
+        decodePayload(in);
+    }
+
+    void encode(BinaryStream& out) const final
+    {
+        out.buffer.clear();
+        out.offset = 0;
+
+        BinaryStream payload;
+        encodePayload(payload);
+
+        out.writeU8(0xFE); 
+        out.writeI8(static_cast<int8_t>(payload.length() + 1)); // + packetId
+        out.writeU8(static_cast<uint8_t>(networkId()));
+
+        out.writeBuffer(payload.data(), payload.length());
+    }
+
+
+protected:
+    virtual void decodePayload(BinaryStream& in) = 0;
+    virtual void encodePayload(BinaryStream& out) const = 0;
+};
diff --git a/src/network/mcbe/packet_direction.hpp b/src/network/mcbe/packet_direction.hpp
new file mode 100644
index 0000000..7e63d52
--- /dev/null
+++ b/src/network/mcbe/packet_direction.hpp
@@ -0,0 +1,9 @@
+#pragma once
+#include <cstdint>
+
+enum class PacketDirection : uint8_t
+{
+    Clientbound = 1,
+    Serverbound = 2,
+    Bidirectional = 3
+};
diff --git a/src/network/mcbe/packet_pool.cpp b/src/network/mcbe/packet_pool.cpp
new file mode 100644
index 0000000..50feb47
--- /dev/null
+++ b/src/network/mcbe/packet_pool.cpp
@@ -0,0 +1,15 @@
+#include "network/mcbe/packet_pool.hpp"
+
+#include "protocol/request_network_settings.hpp"
+#include "protocol/network_settings.hpp"
+#include "protocol/login.hpp"
+#include "protocol/play_status.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+
+void PacketPool::registerAll()
+{
+    bind(ProtocolInfo::REQUEST_NETWORK_SETTINGS_PACKET, [] { return std::make_unique<RequestNetworkSettingsPacket>(); }, PacketDirection::Serverbound);
+    bind(ProtocolInfo::NETWORK_SETTINGS_PACKET, [] { return std::make_unique<NetworkSettingsPacket>(); }, PacketDirection::Clientbound);
+    bind(ProtocolInfo::LOGIN_PACKET, [] { return std::make_unique<LoginPacket>(); }, PacketDirection::Serverbound);
+    bind(ProtocolInfo::PLAY_STATUS_PACKET, [] { return std::make_unique<PlayStatusPacket>(); }, PacketDirection::Clientbound);
+}
diff --git a/src/network/mcbe/packet_pool.hpp b/src/network/mcbe/packet_pool.hpp
new file mode 100644
index 0000000..5bc8cba
--- /dev/null
+++ b/src/network/mcbe/packet_pool.hpp
@@ -0,0 +1,53 @@
+#pragma once
+
+#include "network/mcbe/packet_direction.hpp"
+#include "network/mcbe/packetbase.hpp"
+
+#include <functional>
+#include <memory>
+#include <unordered_map>
+
+class PacketPool
+{
+public:
+    using Factory = std::function<std::unique_ptr<PacketBase>()>;
+
+    struct Entry
+    {
+        Factory factory{};
+        PacketDirection direction{PacketDirection::Bidirectional};
+    };
+
+
+    static PacketPool& instance()
+    {
+        static PacketPool p;
+        return p;
+    }
+
+    void bind(uint32_t id, Factory f, PacketDirection dir)
+    {
+        entries[id] = {std::move(f), dir};
+    }
+
+    std::unique_ptr<PacketBase> create(uint32_t id) const
+    {
+        auto it = entries.find(id);
+        if (it == entries.end())
+            return nullptr;
+        return it->second.factory();
+    }
+
+    PacketDirection direction(uint32_t id) const
+    {
+        auto it = entries.find(id);
+        if (it == entries.end())
+            return PacketDirection::Bidirectional;
+        return it->second.direction;
+    }
+
+    void registerAll();
+
+private:
+    std::unordered_map<uint32_t, Entry> entries;
+};
diff --git a/src/network/mcbe/packetbase.hpp b/src/network/mcbe/packetbase.hpp
new file mode 100644
index 0000000..9633ba2
--- /dev/null
+++ b/src/network/mcbe/packetbase.hpp
@@ -0,0 +1,23 @@
+#pragma once
+
+#include <string>
+#include "packet_direction.hpp"
+#include <cstdint>
+
+class BinaryStream;
+class NetworkSession;
+
+class PacketBase
+{
+public:
+    virtual ~PacketBase() = default;
+
+    virtual uint32_t networkId() const = 0;
+    virtual PacketDirection direction() const = 0;
+    virtual bool allowBeforeLogin() const = 0;
+
+    virtual void decode(BinaryStream& in) = 0;
+    virtual void encode(BinaryStream& out) const = 0;
+
+    virtual bool handle(NetworkSession& session) = 0;
+};
diff --git a/src/network/mcbe/protocol/login.hpp b/src/network/mcbe/protocol/login.hpp
new file mode 100644
index 0000000..66de761
--- /dev/null
+++ b/src/network/mcbe/protocol/login.hpp
@@ -0,0 +1,83 @@
+#pragma once
+
+#include "network/mcbe/packet.hpp"
+#include "network/mcbe/packet_direction.hpp"
+#include "util/textformat.hpp"
+
+#include <iostream>
+
+class LoginPacket final : public Packet
+{
+public:
+    uint32_t protocol = 0;
+    std::string authInfoJson;
+    std::string clientDataJwt;
+
+    uint32_t networkId() const override
+    {
+        return ProtocolInfo::LOGIN_PACKET;
+    }
+
+    PacketDirection direction() const override
+    {
+        return PacketDirection::Serverbound;
+    }
+
+    bool allowBeforeLogin() const override
+    {
+        return false;
+    }
+
+protected:
+    void decodePayload(BinaryStream& in) override
+    {
+        protocol = in.readU32BE();
+        std::cout
+            << (util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::GREEN) + "[MCBE] ", true) +
+                util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::EMERALD) +
+                                                    "Received Protocol Version (LoginPacket): ",
+                                                false))
+            << protocol << std::endl;
+        std::string connectionRequest = in.readString();
+        tryDecodeRequestForConnection(connectionRequest);
+    }
+
+    void encodePayload(BinaryStream& out) const override
+    {
+        out.writeU32BE(protocol);
+        out.writeString(tryEncodeRequestForConnection());
+    }
+
+public:
+    bool handle(NetworkSession& session) override
+    {
+        return false;
+    }
+
+private:
+    void tryDecodeRequestForConnection(const std::string& binary)
+    {
+        BinaryStream cr(reinterpret_cast<const uint8_t*>(binary.data()), binary.size());
+
+        uint32_t authLen = cr.readU32LE();
+        authInfoJson.assign(reinterpret_cast<const char*>(cr.data() + cr.offset), authLen);
+        cr.offset += authLen;
+
+        uint32_t clientLen = cr.readU32LE();
+        clientDataJwt.assign(reinterpret_cast<const char*>(cr.data() + cr.offset), clientLen);
+        cr.offset += clientLen;
+    }
+
+    std::string tryEncodeRequestForConnection() const
+    {
+        BinaryStream cr;
+
+        cr.writeU32LE(static_cast<uint32_t>(authInfoJson.size()));
+        cr.writeBuffer(reinterpret_cast<const uint8_t*>(authInfoJson.data()), authInfoJson.size());
+
+        cr.writeU32LE(static_cast<uint32_t>(clientDataJwt.size()));
+        cr.writeBuffer(reinterpret_cast<const uint8_t*>(clientDataJwt.data()), clientDataJwt.size());
+
+        return std::string(reinterpret_cast<const char*>(cr.data()), cr.length());
+    }
+};
diff --git a/src/network/mcbe/protocol/network_settings.hpp b/src/network/mcbe/protocol/network_settings.hpp
new file mode 100644
index 0000000..4a89423
--- /dev/null
+++ b/src/network/mcbe/protocol/network_settings.hpp
@@ -0,0 +1,63 @@
+﻿#pragma once
+
+#include "network/mcbe/packet.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+#include "network/util/binary_stream.hpp"
+
+#include <cstdint>
+
+class NetworkSettingsPacket final : public Packet
+{
+public:
+    static constexpr uint16_t COMPRESS_NOTHING = 0;
+    static constexpr uint16_t COMPRESS_EVERYTHING = 1;
+
+    int8_t compressionThreshold = 1;
+    int8_t compressionAlgorithm = 0;
+
+    int16_t padding = 0;
+
+    bool enableClientThrottling = false;
+    int8_t clientThrottleThreshold = 0;
+    float clientThrottleScalar = 0.0f;
+
+    int8_t trailingZero = 0;
+
+    uint32_t networkId() const override
+    {
+        return ProtocolInfo::NETWORK_SETTINGS_PACKET;
+    }
+
+    PacketDirection direction() const override
+    {
+        return PacketDirection::Clientbound;
+    }
+
+    bool allowBeforeLogin() const override
+    {
+        return true;
+    }
+
+protected:
+    void decodePayload(BinaryStream&) override
+    {
+        // NOOP
+    }
+
+    void encodePayload(BinaryStream& out) const override
+    {
+        out.writeI8(compressionThreshold);
+        out.writeI8(compressionAlgorithm);
+        out.writeI16LE(padding);
+        out.writeBool(enableClientThrottling);
+        out.writeI8(clientThrottleThreshold);
+        out.writeFloatLE(clientThrottleScalar);
+        out.writeI8(trailingZero);
+    }
+
+public:
+    bool handle(NetworkSession&) override
+    {
+        return true;
+    }
+};
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/play_status.hpp b/src/network/mcbe/protocol/play_status.hpp
new file mode 100644
index 0000000..27ed725
--- /dev/null
+++ b/src/network/mcbe/protocol/play_status.hpp
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "network/mcbe/packet.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+#include "network/util/binary_stream.hpp"
+
+#include <cstdint>
+
+class PlayStatusPacket final : public Packet
+{
+public:
+    // Mabye make this separately?
+    static constexpr uint32_t LOGIN_SUCCESS = 0;
+    static constexpr uint32_t LOGIN_FAILED_CLIENT = 1;
+    static constexpr uint32_t LOGIN_FAILED_SERVER = 2;
+    static constexpr uint32_t PLAYER_SPAWN = 3;
+    static constexpr uint32_t LOGIN_FAILED_INVALID_TENANT = 4;
+    static constexpr uint32_t LOGIN_FAILED_VANILLA_EDU = 5;
+    static constexpr uint32_t LOGIN_FAILED_EDU_VANILLA = 6;
+    static constexpr uint32_t LOGIN_FAILED_SERVER_FULL = 7;
+    static constexpr uint32_t LOGIN_FAILED_EDITOR_VANILLA = 8;
+    static constexpr uint32_t LOGIN_FAILED_VANILLA_EDITOR = 9;
+
+    uint32_t status = 0;
+
+    uint32_t networkId() const override
+    {
+        return ProtocolInfo::PLAY_STATUS_PACKET;
+    }
+
+    PacketDirection direction() const override
+    {
+        return PacketDirection::Clientbound;
+    }
+
+    bool allowBeforeLogin() const override
+    {
+        return true;
+    }
+
+protected:
+    void decodePayload(BinaryStream& in) override
+    {
+        status = in.readU32BE();
+    }
+
+    void encodePayload(BinaryStream& out) const override
+    {
+        out.writeU32BE(status);
+    }
+
+public:
+    bool handle(NetworkSession& /*session*/) override
+    {
+        return true;
+    }
+};
diff --git a/src/network/mcbe/protocol/protocol_info.hpp b/src/network/mcbe/protocol/protocol_info.hpp
new file mode 100644
index 0000000..d1bf70c
--- /dev/null
+++ b/src/network/mcbe/protocol/protocol_info.hpp
@@ -0,0 +1,28 @@
+#pragma once
+
+#include <cstdint>
+#include <array>
+
+struct ProtocolInfo
+{
+    static constexpr std::uint32_t CURRENT_PROTOCOL = 898;
+    static constexpr const char* MINECRAFT_VERSION = "v1.21.130";
+    static constexpr const char* MINECRAFT_VERSION_NETWORK = "1.21.130";
+
+    static constexpr std::array<std::uint32_t, 1> ACCEPTED_PROTOCOLS = {
+        CURRENT_PROTOCOL
+    };
+
+    static constexpr std::uint8_t LOGIN_PACKET = 0x01;
+    static constexpr std::uint8_t PLAY_STATUS_PACKET = 0x02;
+    static constexpr std::uint8_t SERVER_TO_CLIENT_HANDSHAKE_PACKET = 0x03;
+    static constexpr std::uint8_t CLIENT_TO_SERVER_HANDSHAKE_PACKET = 0x04;
+    static constexpr std::uint8_t RESOURCE_PACKS_INFO_PACKET = 0x06;
+    static constexpr std::uint8_t RESOURCE_PACK_STACK_PACKET = 0x07;
+    static constexpr std::uint8_t START_GAME_PACKET = 0x0b;
+    static constexpr std::uint8_t LEVEL_CHUNK_PACKET = 0x3a;
+    static constexpr std::uint8_t REQUEST_CHUNK_RADIUS_PACKET = 0x45;
+    static constexpr std::uint8_t CHUNK_RADIUS_UPDATED_PACKET = 0x46;
+    static constexpr std::uint8_t NETWORK_SETTINGS_PACKET = 0x8f;
+    static constexpr std::uint8_t REQUEST_NETWORK_SETTINGS_PACKET = 0xc1;
+};
\ No newline at end of file
diff --git a/src/network/mcbe/protocol/request_network_settings.hpp b/src/network/mcbe/protocol/request_network_settings.hpp
new file mode 100644
index 0000000..d63c694
--- /dev/null
+++ b/src/network/mcbe/protocol/request_network_settings.hpp
@@ -0,0 +1,58 @@
+#pragma once
+
+#include "network/mcbe/packet.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+#include "network/util/binary_stream.hpp"
+#include "network/session/network_session.hpp"
+#include "network/mcbe/protocol/network_settings.hpp"
+#include "util/textformat.hpp"
+#include "network/mcbe/protocol/types/CompressionAlgorithm.hpp"
+#include <RakNet/RakNetTypes.h>
+
+#include <iostream>
+#include <cstdint>
+
+class RequestNetworkSettingsPacket final : public Packet
+{
+public:
+    uint32_t protocolVersion = 0;
+
+    uint32_t networkId() const override
+    {
+        return ProtocolInfo::REQUEST_NETWORK_SETTINGS_PACKET;
+    }
+
+    PacketDirection direction() const override
+    {
+        return PacketDirection::Serverbound;
+    }
+
+    bool allowBeforeLogin() const override
+    {
+        return true;
+    }
+
+protected:
+    void decodePayload(BinaryStream& in) override
+    {
+        protocolVersion = in.readU32BE();
+        std::cout
+            << (util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::GREEN) + "[MCBE] ", true) +
+                util::textformat::renderConsole(util::textformat::bedrock(util::textformat::Color::EMERALD) +
+                                                    "Received Protocol Version (RequestNetworkSettings): ",
+                                                false))
+            << protocolVersion << std::endl;
+    }
+
+    void encodePayload(BinaryStream&) const override
+    {
+        // NOOP
+    }
+
+public:
+    bool handle(NetworkSession& session) override
+    {
+        session.handleRequestNetworkSettings(*this);
+        return true;
+    }
+};
diff --git a/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp b/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp
new file mode 100644
index 0000000..1caec92
--- /dev/null
+++ b/src/network/mcbe/protocol/types/CompressionAlgorithm.hpp
@@ -0,0 +1,13 @@
+#pragma once
+
+#include <cstdint>
+
+namespace mcpe::protocol::types
+{
+enum class CompressionAlgorithm : std::uint8_t
+{
+    ZLIB = 0,
+    SNAPPY = 1,
+    NONE = 0xFF
+};
+} // namespace mcpe::protocol::types
diff --git a/src/network/mcbe/protocol/types/GameMode.hpp b/src/network/mcbe/protocol/types/GameMode.hpp
new file mode 100644
index 0000000..1516fa5
--- /dev/null
+++ b/src/network/mcbe/protocol/types/GameMode.hpp
@@ -0,0 +1,90 @@
+#pragma once
+#include <string_view>
+
+#include <cstdint>
+
+namespace mcpe::protocol::types
+{
+
+// somewhat valid implemention, i wouldnt say fully but eh it works
+enum class GameMode : std::uint8_t
+{
+    SURVIVAL = 0,
+    CREATIVE = 1,
+    ADVENTURE = 2,
+    SURVIVAL_VIEWER = 3,
+    CREATIVE_VIEWER = 4,
+    DEFAULT = 5
+};
+
+constexpr std::string_view toString(GameMode mode) noexcept
+{
+    switch (mode)
+    {
+        case GameMode::SURVIVAL:
+            return "Survival";
+        case GameMode::CREATIVE:
+            return "Creative";
+        case GameMode::ADVENTURE:
+            return "Adventure";
+        case GameMode::SURVIVAL_VIEWER:
+            return "Survival Viewer";
+        case GameMode::CREATIVE_VIEWER:
+            return "Creative Viewer";
+        case GameMode::DEFAULT:
+            return "Default";
+        default:
+            return "Unknown";
+    }
+}
+
+constexpr bool iequals(std::string_view a, std::string_view b) noexcept
+{
+    if (a.size() != b.size())
+        return false;
+    for (size_t i = 0; i < a.size(); ++i)
+    {
+        auto ca = a[i];
+        auto cb = b[i];
+        if (ca >= 'A' && ca <= 'Z')
+            ca += 32;
+        if (cb >= 'A' && cb <= 'Z')
+            cb += 32;
+        if (ca != cb)
+            return false;
+    }
+    return true;
+}
+
+constexpr GameMode fromString(std::string_view str) noexcept
+{
+    if (iequals(str, "survival") || iequals(str, "s"))
+    {
+        return GameMode::SURVIVAL;
+    }
+    if (iequals(str, "creative") || iequals(str, "c"))
+    {
+        return GameMode::CREATIVE;
+    }
+    if (iequals(str, "adventure") || iequals(str, "a"))
+    {
+        return GameMode::ADVENTURE;
+    }
+    if (iequals(str, "survival_viewer") || iequals(str, "survival viewer") || iequals(str, "spectator") ||
+        iequals(str, "spec"))
+    {
+        return GameMode::SURVIVAL_VIEWER;
+    }
+    if (iequals(str, "creative_viewer") || iequals(str, "creative viewer"))
+    {
+        return GameMode::CREATIVE_VIEWER;
+    }
+    if (iequals(str, "default"))
+    {
+        return GameMode::DEFAULT;
+    }
+
+    return GameMode::DEFAULT;
+}
+
+} // namespace mcpe::protocol::types
diff --git a/src/network/mcbe/transport.hpp b/src/network/mcbe/transport.hpp
new file mode 100644
index 0000000..f8f7e58
--- /dev/null
+++ b/src/network/mcbe/transport.hpp
@@ -0,0 +1,14 @@
+#pragma once
+
+#include <RakNet/RakNetTypes.h>
+
+#include <cstddef>
+#include <cstdint>
+
+class Transport
+{
+public:
+    virtual ~Transport() = default;
+
+    virtual void send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len) = 0;
+};
diff --git a/src/network/raknet/mcbe_packet_router.cpp b/src/network/raknet/mcbe_packet_router.cpp
new file mode 100644
index 0000000..e666bdc
--- /dev/null
+++ b/src/network/raknet/mcbe_packet_router.cpp
@@ -0,0 +1,15 @@
+#include "mcbe_packet_router.hpp"
+
+#include "network/session/network_session.hpp"
+
+void McbePacketRouter::route(RakNet::Packet* p, RaknetConnections& connections)
+{
+    if (p->length <= 1)
+        return;
+
+    auto* session = connections.get(p->guid);
+    if (!session)
+        return;
+
+    session->onRaw(*p, p->data + 1, p->length - 1);
+}
diff --git a/src/network/raknet/mcbe_packet_router.hpp b/src/network/raknet/mcbe_packet_router.hpp
new file mode 100644
index 0000000..277634d
--- /dev/null
+++ b/src/network/raknet/mcbe_packet_router.hpp
@@ -0,0 +1,8 @@
+#pragma once
+#include "raknet_connections.hpp"
+
+class McbePacketRouter
+{
+public:
+    static void route(RakNet::Packet* p, RaknetConnections& connections);
+};
diff --git a/src/network/raknet/raknet_connections.cpp b/src/network/raknet/raknet_connections.cpp
new file mode 100644
index 0000000..0d055c9
--- /dev/null
+++ b/src/network/raknet/raknet_connections.cpp
@@ -0,0 +1,34 @@
+#include "raknet_connections.hpp"
+
+#include "network/session/network_session.hpp"
+#include "raknet_handler.hpp"
+#include "util/textformat.hpp"
+
+#include <iostream>
+using namespace util::textformat;
+
+void RaknetConnections::onConnect(const RakNet::RakNetGUID& guid, RakNet::SystemAddress address, RaknetHandler* handler)
+{
+    auto session = std::make_unique<NetworkSession>(guid, address, handler->transport());
+
+    session->setCompressor(std::make_unique<ZlibCompressor>(6, std::optional<size_t>{0}, 2 * 1024 * 1024));
+
+    sessions.emplace(guid, std::move(session));
+
+    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] " + bedrock(Color::DARK_GRAY) + "New incoming connection", true)
+              << std::endl;
+}
+
+void RaknetConnections::onDisconnect(const RakNet::RakNetGUID& guid)
+{
+    sessions.erase(guid);
+    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] ", true) + renderConsole(bedrock(Color::DARK_GRAY) + "Disconnected client ", false) << std::endl;
+}
+
+NetworkSession* RaknetConnections::get(const RakNet::RakNetGUID& guid)
+{
+    auto it = sessions.find(guid);
+    if (it == sessions.end())
+        return nullptr;
+    return it->second.get();
+}
diff --git a/src/network/raknet/raknet_connections.hpp b/src/network/raknet/raknet_connections.hpp
new file mode 100644
index 0000000..76fb88f
--- /dev/null
+++ b/src/network/raknet/raknet_connections.hpp
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "raknet_guid_hash.hpp"
+
+#include <RakNet/RakNetTypes.h>
+#include <memory>
+#include <unordered_map>
+
+class NetworkSession;
+class RaknetHandler;
+
+class RaknetConnections
+{
+public:
+    void onConnect(const RakNet::RakNetGUID& guid, RakNet::SystemAddress address, RaknetHandler* handler);
+    void onDisconnect(const RakNet::RakNetGUID& guid);
+    NetworkSession* get(const RakNet::RakNetGUID& guid);
+
+private:
+    std::unordered_map<RakNet::RakNetGUID, std::unique_ptr<NetworkSession>> sessions;
+};
diff --git a/src/network/raknet/raknet_guid_hash.hpp b/src/network/raknet/raknet_guid_hash.hpp
new file mode 100644
index 0000000..79ee971
--- /dev/null
+++ b/src/network/raknet/raknet_guid_hash.hpp
@@ -0,0 +1,16 @@
+#pragma once
+
+#include <RakNet/RakNetTypes.h>
+#include <functional>
+
+namespace std
+{
+template <>
+struct hash<RakNet::RakNetGUID>
+{
+    size_t operator()(const RakNet::RakNetGUID& guid) const noexcept
+    {
+        return std::hash<uint64_t>{}(guid.g);
+    }
+};
+} // namespace std
diff --git a/src/network/raknet/raknet_handler.cpp b/src/network/raknet/raknet_handler.cpp
new file mode 100644
index 0000000..b83bf73
--- /dev/null
+++ b/src/network/raknet/raknet_handler.cpp
@@ -0,0 +1,154 @@
+#include "raknet_handler.hpp"
+
+#include "network/session/network_session.hpp"
+#include "raknet_motd.hpp"
+#include "server.hpp"
+
+#include "util/textformat.hpp"
+#include "raknet_transport.hpp"
+
+#include <iostream>
+using namespace util::textformat;
+
+RaknetHandler::RaknetHandler()
+{
+    Server& server = Server::getInstance();
+
+    peer = RakNet::RakPeerInterface::GetInstance();
+    RakNet::SocketDescriptor sd(server.getPort(), nullptr);
+    peer->Startup(server.getMaxPlayers(), &sd, 1);
+    peer->SetMaximumIncomingConnections(server.getMaxPlayers());
+
+    std::string motd = buildRaknetMotd();
+    std::string response;
+
+    uint16_t len = static_cast<uint16_t>(motd.size());
+    response.push_back((len >> 8) & 0xFF);
+    response.push_back(len & 0xFF);
+    response += motd;
+
+    peer->SetOfflinePingResponse(response.c_str(), response.size());
+
+    transportImpl = std::make_unique<RaknetTransport>(peer);
+    std::cout << renderConsole(bedrock(Color::RED) + "[RAKNET] ", true) + renderConsole(bedrock(Color::DARK_GRAY) + "listening on ", false) << server.getPort() << std::endl;
+}
+
+RaknetHandler::~RaknetHandler()
+{
+    RakNet::RakPeerInterface::DestroyInstance(peer);
+}
+
+Transport* RaknetHandler::transport()
+{
+    return transportImpl.get();
+}
+
+void RaknetHandler::poll()
+{
+    for (RakNet::Packet* p = peer->Receive(); p; peer->DeallocatePacket(p), p = peer->Receive())
+    {
+        handlePacket(p);
+    }
+}
+
+void RaknetHandler::handlePacket(RakNet::Packet* p)
+{
+    switch (p->data[0])
+    {
+        case 0x13:
+            connections.onConnect(p->guid, p->systemAddress, this);
+            break;
+
+        case 0x15:
+            connections.onDisconnect(p->guid);
+            break;
+
+        case 0xFE:
+            handleMcbePacket(p);
+            break;
+
+        default:
+            break;
+    }
+}
+
+void RaknetHandler::handleMcbePacket(RakNet::Packet* p)
+{
+    NetworkSession* session = connections.get(p->guid);
+    if (!session)
+        return;
+
+    const uint8_t* data = p->data + 1;
+    size_t len = p->length - 1;
+
+    if (len == 0)
+        return;
+
+    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
+    //          << renderConsole(bedrock(Color::DARK_GRAY) + " raw payload ", false) << "(" << len << " bytes) : ";
+
+    //for (size_t i = 0; i < len; i++)
+    //    std::printf("%02X ", data[i]);
+    //std::cout << std::endl;
+
+    std::vector<uint8_t> payload;
+
+    if (!session->compressionEnabled)
+    {
+        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE]", true)
+                  << renderConsole(bedrock(Color::GRAY) + " compression DISABLED", false) << std::endl;
+
+        payload.assign(data, data + len);
+    }
+    else
+    {
+        uint8_t compressionMethod = data[0];
+
+        std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                  << renderConsole(bedrock(Color::DARK_GRAY) + " compression method = 0x", false) << std::hex
+                  << (int)compressionMethod << std::dec << std::endl;
+
+        const uint8_t* body = data + 1;
+        size_t bodyLen = len - 1;
+
+        if (compressionMethod == 0xFF)
+        {
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " no compression", false) << std::endl;
+
+            payload.assign(body, body + bodyLen);
+        }
+        else if (compressionMethod == 0x00)
+        {
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " ZLIB decompressing...", false) << std::endl;
+
+            if (!session->compressor().decompress(body, bodyLen, payload))
+            {
+                std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
+                          << renderConsole(bedrock(Color::DARK_GRAY) + " decompression failed", false) << std::endl;
+                return;
+            }
+
+            std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+                      << renderConsole(bedrock(Color::GRAY) + " decompressed size = ", false) << payload.size()
+                      << std::endl;
+        }
+        else
+        {
+            std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
+                      << renderConsole(bedrock(Color::DARK_GRAY) + " unknown compression method = ", false)
+                      << (int)compressionMethod << std::endl;
+            return;
+        }
+    }
+
+    //std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+    //          << renderConsole(bedrock(Color::GRAY) + " final payload: ", false);
+
+ /*   for (uint8_t b : payload)
+        std::printf("%02X ", b);
+    std::cout << std::endl;*/
+
+    session->onRaw(*p, payload.data(), payload.size());
+}
\ No newline at end of file
diff --git a/src/network/raknet/raknet_handler.hpp b/src/network/raknet/raknet_handler.hpp
new file mode 100644
index 0000000..b207306
--- /dev/null
+++ b/src/network/raknet/raknet_handler.hpp
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "network/mcbe/transport.hpp"
+#include "raknet_connections.hpp"
+
+#include <RakNet/RakNetTypes.h>
+#include <RakNet/RakPeerInterface.h>
+
+class RaknetHandler
+{
+public:
+    RaknetHandler();
+    ~RaknetHandler();
+
+    void poll();
+
+    Transport* transport();
+
+private:
+    void handlePacket(RakNet::Packet* p);
+    void handleMcbePacket(RakNet::Packet* p);
+
+private:
+    RakNet::RakPeerInterface* peer;
+    RaknetConnections connections;
+
+    std::unique_ptr<Transport> transportImpl;
+};
diff --git a/src/network/raknet/raknet_motd.cpp b/src/network/raknet/raknet_motd.cpp
new file mode 100644
index 0000000..73211e4
--- /dev/null
+++ b/src/network/raknet/raknet_motd.cpp
@@ -0,0 +1,43 @@
+#include "raknet_motd.hpp"
+
+#include "network/mcbe/protocol/protocol_info.hpp"
+#include "server.hpp"
+
+std::string buildRaknetMotd()
+{
+    Server& server = Server::getInstance();
+    auto gm = server.getDefaultGameMode();
+
+    int gmNumeric = 1;
+    if (gm == mcpe::protocol::types::GameMode::CREATIVE)
+        gmNumeric = 0;
+    if (gm == mcpe::protocol::types::GameMode::ADVENTURE)
+        gmNumeric = 2;
+
+    std::string motd;
+    motd += "MCPE;";
+    motd += server.getMotd();
+    motd += ";";
+    motd += std::to_string(ProtocolInfo::CURRENT_PROTOCOL);
+    motd += ";";
+    motd += ProtocolInfo::MINECRAFT_VERSION_NETWORK;
+    motd += ";";
+    motd += std::to_string(server.getPlayerCount());
+    motd += ";";
+    motd += std::to_string(server.getMaxPlayers());
+    motd += ";";
+    motd += std::to_string(server.getServerUniqueId());
+    motd += ";";
+    motd += server.getServerName();
+    motd += ";";
+    motd += mcpe::protocol::types::toString(gm);
+    motd += ";";
+    motd += std::to_string(gmNumeric);
+    motd += ";";
+    motd += std::to_string(server.getPort());
+    motd += ";";
+    motd += std::to_string(server.getPortIpv6());
+    motd += ";";
+
+    return motd;
+}
diff --git a/src/network/raknet/raknet_motd.hpp b/src/network/raknet/raknet_motd.hpp
new file mode 100644
index 0000000..ce316eb
--- /dev/null
+++ b/src/network/raknet/raknet_motd.hpp
@@ -0,0 +1,4 @@
+#pragma once
+#include <string>
+
+std::string buildRaknetMotd();
diff --git a/src/network/raknet/raknet_peer.cpp b/src/network/raknet/raknet_peer.cpp
new file mode 100644
index 0000000..97926ad
--- /dev/null
+++ b/src/network/raknet/raknet_peer.cpp
@@ -0,0 +1,19 @@
+#include "raknet_peer.hpp"
+
+RaknetPeer::RaknetPeer(uint16_t port, uint32_t maxPlayers)
+{
+    peer = RakNet::RakPeerInterface::GetInstance();
+    RakNet::SocketDescriptor sd(port, nullptr);
+    peer->Startup(maxPlayers, &sd, 1);
+    peer->SetMaximumIncomingConnections(maxPlayers);
+}
+
+RaknetPeer::~RaknetPeer()
+{
+    RakNet::RakPeerInterface::DestroyInstance(peer);
+}
+
+RakNet::RakPeerInterface* RaknetPeer::get()
+{
+    return peer;
+}
diff --git a/src/network/raknet/raknet_peer.hpp b/src/network/raknet/raknet_peer.hpp
new file mode 100644
index 0000000..0981196
--- /dev/null
+++ b/src/network/raknet/raknet_peer.hpp
@@ -0,0 +1,14 @@
+#pragma once
+#include <RakNet/RakPeerInterface.h>
+
+class RaknetPeer
+{
+public:
+    RaknetPeer(uint16_t port, uint32_t maxPlayers);
+    ~RaknetPeer();
+
+    RakNet::RakPeerInterface* get();
+
+private:
+    RakNet::RakPeerInterface* peer;
+};
diff --git a/src/network/raknet/raknet_transport.cpp b/src/network/raknet/raknet_transport.cpp
new file mode 100644
index 0000000..5695878
--- /dev/null
+++ b/src/network/raknet/raknet_transport.cpp
@@ -0,0 +1,7 @@
+#include "raknet_transport.hpp"
+#include <iostream>
+
+void RaknetTransport::send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len)
+{
+    peer->Send(reinterpret_cast<const char*>(data), len, HIGH_PRIORITY, RELIABLE_ORDERED, 0, guid, false);
+}
diff --git a/src/network/raknet/raknet_transport.hpp b/src/network/raknet/raknet_transport.hpp
new file mode 100644
index 0000000..8ec014c
--- /dev/null
+++ b/src/network/raknet/raknet_transport.hpp
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "network/mcbe/transport.hpp"
+
+#include <RakNet/RakNetTypes.h>
+#include <RakNet/RakPeerInterface.h>
+
+class RaknetTransport : public Transport
+{
+public:
+    explicit RaknetTransport(RakNet::RakPeerInterface* peer) : peer(peer)
+    {
+    }
+
+    void send(const RakNet::RakNetGUID& guid, const uint8_t* data, size_t len) override;
+
+private:
+    RakNet::RakPeerInterface* peer = nullptr;
+};
diff --git a/src/network/session/network_session.cpp b/src/network/session/network_session.cpp
new file mode 100644
index 0000000..faaecfd
--- /dev/null
+++ b/src/network/session/network_session.cpp
@@ -0,0 +1,133 @@
+﻿#include "network_session.hpp"
+
+#include "network/mcbe/protocol/network_settings.hpp"
+#include "network/mcbe/protocol/protocol_info.hpp"
+#include "network/util/binary_stream.hpp"
+#include "util/textformat.hpp"
+#include "network/mcbe/protocol/play_status.hpp"
+#include "network/mcbe/handler/session_begin_handler.hpp"
+
+#include <iomanip>
+#include <iostream>
+#include <sstream>
+#include <vector>
+using namespace util::textformat;
+
+void NetworkSession::onRaw(RakNet::Packet, const uint8_t* data, size_t len)
+{
+    BinaryStream in(data, len);
+
+    uint32_t packetLength = in.readVarUInt();
+    uint32_t packetId = in.readVarUInt();
+
+    std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+              << renderConsole(bedrock(Color::DARK_GRAY) + " packet length = ", false) << packetLength << std::endl;
+
+    std::cout << renderConsole(bedrock(Color::GREEN) + "[MCBE][DEBUG]", true)
+              << renderConsole(bedrock(Color::DARK_GRAY) + " packet id = 0x", false) << std::hex << packetId << std::dec
+              << std::endl;
+
+    auto packet = PacketPool::instance().create(packetId);
+    if (!packet)
+    {
+        std::cout << renderConsole(bedrock(Color::RED) + "[MCBE][ERROR]", true)
+                  << renderConsole(bedrock(Color::DARK_GRAY) + " unknown packet id", false) << std::endl;
+        return;
+    }
+
+    packet->decode(in);
+    packet->handle(*this);
+}
+
+static std::string hexDump(const uint8_t* data, size_t len)
+{
+    std::ostringstream oss;
+    oss << std::hex << std::uppercase << std::setfill('0');
+
+    for (size_t i = 0; i < len; ++i)
+    {
+        oss << std::setw(2) << static_cast<int>(data[i]);
+        if (i + 1 < len)
+            oss << ' ';
+    }
+
+    return oss.str();
+}
+
+// TODO: give better name
+bool NetworkSession::disconnectUserForIncompatiableProtocol(uint32_t protocolVersion) 
+{
+    PlayStatusPacket packet{};
+    packet.status = protocolVersion < ProtocolInfo::CURRENT_PROTOCOL
+                        ? PlayStatusPacket::LOGIN_FAILED_CLIENT
+                        : PlayStatusPacket::LOGIN_FAILED_SERVER;
+    send(packet);
+    return true;
+}
+
+void NetworkSession::send(PacketBase& packet)
+{
+    if (PacketPool::instance().direction(packet.networkId()) == PacketDirection::Serverbound)
+    {
+        return;
+    }
+
+    BinaryStream payload;
+    packet.encode(payload);
+
+    std::vector<uint8_t> out;
+
+    if (!compressionEnabled || compressor().networkId() == mcpe::protocol::types::CompressionAlgorithm::NONE)
+    {
+        out.assign(payload.data(), payload.data() + payload.length());
+    }
+    else if (compressor().networkId() == mcpe::protocol::types::CompressionAlgorithm::ZLIB)
+    {
+        auto threshold = compressor().compressionThreshold().value_or(0);
+
+        if (payload.length() >= threshold)
+        {
+            std::vector<uint8_t> compressed;
+
+            if (!compressor().compress(payload.data(), payload.length(), compressed))
+            {
+                std::cout << renderConsole(bedrock(Color::RED) + "[Cyrex][ERROR]", true)
+                          << renderConsole(bedrock(Color::DARK_GRAY) + " compression failed", false) << std::endl;
+                return;
+            }
+
+            out.push_back(static_cast<uint8_t>(mcpe::protocol::types::CompressionAlgorithm::ZLIB));
+            out.insert(out.end(), compressed.begin(), compressed.end());
+        }
+        else
+        {
+            out.push_back(static_cast<uint8_t>(mcpe::protocol::types::CompressionAlgorithm::NONE));
+            out.insert(out.end(), payload.data(), payload.data() + payload.length());
+        }
+    }
+
+    std::string msg = bedrock(Color::BLUE) + "[Cyrex] " + bedrock(Color::DARK_GRAY) +
+                      "send packet id=" + bedrock(Color::GOLD) + std::to_string(packet.networkId());
+
+    std::cout << renderConsole(msg, true) << std::endl;
+
+    std::string dump = hexDump(out.data(), out.size());
+
+    std::cout << renderConsole(bedrock(Color::BLUE) + "[Cyrex]", true)
+              << renderConsole(bedrock(Color::DARK_GRAY) + " send payload: " + bedrock(Color::GRAY) + dump, false)
+              << std::endl;
+
+    m_transport->send(m_guid, out.data(), out.size());
+}
+
+void NetworkSession::setCompressor(std::unique_ptr<Compressor> comp)
+{
+    m_compressor = std::move(comp);
+}
+
+bool NetworkSession::handleRequestNetworkSettings(PacketBase& packet)
+{
+    SessionBeginHandler handler{};
+    handler.handle(*this, packet);
+    return true;
+}
\ No newline at end of file
diff --git a/src/network/session/network_session.hpp b/src/network/session/network_session.hpp
new file mode 100644
index 0000000..f18df9b
--- /dev/null
+++ b/src/network/session/network_session.hpp
@@ -0,0 +1,76 @@
+#pragma once
+
+#include "network/mcbe/compression/compressor.hpp"
+#include "network/mcbe/compression/noop_compressor.hpp"
+#include "network/mcbe/compression/zlib_compressor.hpp"
+#include "network/mcbe/packet.hpp"
+#include "network/mcbe/packet_pool.hpp"
+#include "network/mcbe/transport.hpp"
+#include "network/util/binary_stream.hpp"
+
+#include <RakNet/RakNetTypes.h>
+#include <memory>
+
+#include <cstdint>
+
+enum class Phase
+{
+    HANDSHAKE,
+    PLAY
+};
+
+class NetworkSession
+{
+public:
+    NetworkSession(RakNet::RakNetGUID guid, RakNet::SystemAddress address, Transport* transport) :
+        m_guid(guid),
+        m_address(address),
+        m_transport(transport),
+        m_protocolId(0),
+        m_compressor(std::make_unique<NoopCompressor>())
+    {
+    }
+
+    bool compressionEnabled = false;
+    Phase phase = Phase::HANDSHAKE;
+
+    void onRaw(RakNet::Packet packet, const uint8_t* data, size_t len);
+    void send(PacketBase& packet);
+    bool disconnectUserForIncompatiableProtocol(uint32_t);
+    bool handleRequestNetworkSettings(PacketBase& packet);
+
+    void setCompressor(std::unique_ptr<Compressor> compressor);
+
+    Compressor& compressor() const
+    {
+        return *m_compressor;
+    }
+
+    void setProtocolId(std::uint32_t protocolId)
+    {
+        m_protocolId = protocolId;
+    }
+
+    std::uint32_t protocolId() const
+    {
+        return m_protocolId;
+    }
+
+    RakNet::RakNetGUID guid() const
+    {
+        return m_guid;
+    }
+
+    RakNet::SystemAddress address() const
+    {
+        return m_address;
+    }
+
+private:
+    RakNet::RakNetGUID m_guid;
+    RakNet::SystemAddress m_address;
+    Transport* m_transport;
+
+    std::uint32_t m_protocolId;
+    std::unique_ptr<Compressor> m_compressor;
+};
diff --git a/src/network/util/binary_stream.hpp b/src/network/util/binary_stream.hpp
new file mode 100644
index 0000000..4726dd1
--- /dev/null
+++ b/src/network/util/binary_stream.hpp
@@ -0,0 +1,334 @@
+#pragma once
+
+#include "math/vector2.hpp"
+#include "math/vector3.hpp"
+
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+#include <cstdint>
+#include <cstring>
+
+class BinaryStream
+{
+public:
+    BinaryStream() = default;
+
+    BinaryStream(const uint8_t* data, size_t len) : buffer(data, data + len), offset(0)
+    {
+    }
+
+    std::vector<uint8_t> buffer;
+    size_t offset = 0;
+
+    size_t remaining() const
+    {
+        return buffer.size() - offset;
+    }
+
+    void reset()
+    {
+        offset = 0;
+    }
+
+    uint8_t readU8()
+    {
+        ensureReadable(1);
+        return buffer[offset++];
+    }
+
+    int8_t readI8()
+    {
+        return static_cast<int8_t>(readU8());
+    }
+
+    uint16_t readU16LE()
+    {
+        ensureReadable(2);
+        uint16_t v = buffer[offset] | (buffer[offset + 1] << 8);
+        offset += 2;
+        return v;
+    }
+
+    uint16_t readU16BE()
+    {
+        ensureReadable(2);
+        uint16_t v = (buffer[offset] << 8) | buffer[offset + 1];
+        offset += 2;
+        return v;
+    }
+
+    int16_t readI16LE()
+    {
+        return static_cast<int16_t>(readU16LE());
+    }
+
+    int16_t readI16BE()
+    {
+        return static_cast<int16_t>(readU16BE());
+    }
+
+    uint32_t readU32LE()
+    {
+        ensureReadable(4);
+        uint32_t v = buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24);
+        offset += 4;
+        return v;
+    }
+
+    uint32_t readU32BE()
+    {
+        ensureReadable(4);
+        uint32_t v = (buffer[offset] << 24) | (buffer[offset + 1] << 16) | (buffer[offset + 2] << 8) | buffer[offset + 3];
+        offset += 4;
+        return v;
+    }
+
+    uint64_t readU64LE()
+    {
+        ensureReadable(8);
+        uint64_t v = 0;
+        for (int i = 0; i < 8; ++i)
+            v |= uint64_t(buffer[offset + i]) << (i * 8);
+        offset += 8;
+        return v;
+    }
+
+    uint64_t readU64BE()
+    {
+        ensureReadable(8);
+        uint64_t v = 0;
+        for (int i = 0; i < 8; ++i)
+            v = (v << 8) | buffer[offset + i];
+        offset += 8;
+        return v;
+    }
+
+    bool readBool()
+    {
+        return readU8() != 0;
+    }
+
+    float readFloatLE()
+    {
+        uint32_t bits = readU32LE();
+        float f;
+        std::memcpy(&f, &bits, sizeof(float));
+        return f;
+    }
+
+    double readDoubleLE()
+    {
+        uint64_t bits = readU64LE();
+        double d;
+        std::memcpy(&d, &bits, sizeof(double));
+        return d;
+    }
+
+    uint32_t readVarUInt()
+    {
+        uint32_t value = 0;
+        int shift = 0;
+
+        for (int i = 0; i < 5; ++i)
+        {
+            uint8_t b = readU8();
+            value |= uint32_t(b & 0x7F) << shift;
+            if ((b & 0x80) == 0)
+                return value;
+            shift += 7;
+        }
+
+        throw std::runtime_error("VarUInt overflow");
+    }
+
+    int32_t readVarInt()
+    {
+        return static_cast<int32_t>(readVarUInt());
+    }
+
+    uint64_t readVarULong()
+    {
+        uint64_t value = 0;
+        int shift = 0;
+
+        for (int i = 0; i < 10; ++i)
+        {
+            uint8_t b = readU8();
+            value |= uint64_t(b & 0x7F) << shift;
+            if ((b & 0x80) == 0)
+                return value;
+            shift += 7;
+        }
+
+        throw std::runtime_error("VarULong overflow");
+    }
+
+    int64_t readVarLong()
+    {
+        return static_cast<int64_t>(readVarULong());
+    }
+
+    std::string readString()
+    {
+        uint32_t len = readVarUInt();
+        ensureReadable(len);
+        std::string s(reinterpret_cast<char*>(&buffer[offset]), len);
+        offset += len;
+        return s;
+    }
+
+    Vector2 readVector2()
+    {
+        return {readFloatLE(), readFloatLE()};
+    }
+
+    Vector3 readVector3()
+    {
+        return {readFloatLE(), readFloatLE(), readFloatLE()};
+    }
+
+    void writeU8(uint8_t v)
+    {
+        buffer.push_back(v);
+    }
+
+    void writeI8(int8_t v)
+    {
+        writeU8(static_cast<uint8_t>(v));
+    }
+
+    void writeU16LE(uint16_t v)
+    {
+        writeU8(v);
+        writeU8(v >> 8);
+    }
+
+    void writeU16BE(uint16_t v)
+    {
+        writeU8(v >> 8);
+        writeU8(v);
+    }
+
+    void writeI16LE(int16_t v)
+    {
+        writeU16LE(static_cast<uint16_t>(v));
+    }
+
+    void writeI16BE(int16_t v)
+    {
+        writeU16BE(static_cast<uint16_t>(v));
+    }
+
+    void writeU32BE(uint32_t v)
+    {
+        writeU8(static_cast<uint8_t>(v >> 24));
+        writeU8(static_cast<uint8_t>(v >> 16));
+        writeU8(static_cast<uint8_t>(v >> 8));
+        writeU8(static_cast<uint8_t>(v));
+    }
+
+    void writeU32LE(uint32_t v)
+    {
+        writeU8(v);
+        writeU8(v >> 8);
+        writeU8(v >> 16);
+        writeU8(v >> 24);
+    }
+
+    void writeU64LE(uint64_t v)
+    {
+        for (int i = 0; i < 8; ++i)
+            writeU8(v >> (i * 8));
+    }
+
+    void writeBool(bool v)
+    {
+        writeU8(v ? 1 : 0);
+    }
+
+    void writeFloatLE(float v)
+    {
+        uint32_t bits;
+        std::memcpy(&bits, &v, sizeof(bits));
+        writeU32LE(bits);
+    }
+
+    void writeDoubleLE(double v)
+    {
+        uint64_t bits;
+        std::memcpy(&bits, &v, sizeof(bits));
+        writeU64LE(bits);
+    }
+
+    void writeBuffer(const uint8_t* data, size_t len)
+    {
+        buffer.insert(buffer.end(), data, data + len);
+    }
+
+    void writeVarUInt(uint32_t v)
+    {
+        while (true)
+        {
+            uint8_t b = v & 0x7F;
+            v >>= 7;
+            if (v)
+                writeU8(b | 0x80);
+            else
+            {
+                writeU8(b);
+                break;
+            }
+        }
+    } 
+
+    void writeVarInt(int32_t v)
+    {
+        writeVarUInt(static_cast<uint32_t>(v));
+    }
+
+    void writeVarLong(int64_t v)
+    {
+        writeVarULong(static_cast<uint64_t>(v));
+    }
+
+    void writeVarULong(uint64_t v)
+    {
+        while (true)
+        {
+            uint8_t b = v & 0x7F;
+            v >>= 7;
+            if (v)
+                writeU8(b | 0x80);
+            else
+            {
+                writeU8(b);
+                break;
+            }
+        }
+    }
+
+    void writeString(const std::string& s)
+    {
+        writeVarUInt(static_cast<uint32_t>(s.size()));
+        buffer.insert(buffer.end(), s.begin(), s.end());
+    }
+
+    const uint8_t* data() const
+    {
+        return buffer.data();
+    }
+
+    size_t length() const
+    {
+        return buffer.size();
+    }
+
+private:
+    void ensureReadable(size_t n)
+    {
+        if (offset + n > buffer.size())
+            throw std::runtime_error("BinaryStream overflow");
+    }
+};
diff --git a/src/player/player.cpp b/src/player/player.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/player/player.hpp b/src/player/player.hpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server.cpp b/src/server.cpp
index 0c87cb7..b5b9270 100644
--- a/src/server.cpp
+++ b/src/server.cpp
@@ -1,97 +1,156 @@
-#include "server.hpp"
+﻿#include "server.hpp"
 
+#include "network/raknet/raknet_handler.hpp"
+#include "util/textformat.hpp"
+
+#include <algorithm>
+#include <chrono>
 #include <iostream>
-#include <magic_enum/magic_enum.hpp>
+#include <random>
+#include <thread>
 
-// Raknet
-#include <RakNet/MessageIdentifiers.h>
-#include <RakNet/RakSleep.h>
+cyrex::Server* cyrex::Server::s_instance = nullptr;
 
-///  Exceptions
-cyrex::Server::InitFailedError::InitFailedError(const std::string& message) : std::runtime_error(message)
+cyrex::Server::Config cyrex::Server::Config::fromProperties(const cyrex::util::ServerProperties& p)
 {
+    return {p.port, p.portIpv6, p.maxPlayers, p.serverName, p.motd, p.defaultGameMode};
 }
 
-cyrex::Server::NullPacketException::NullPacketException(const std::string& message) : std::runtime_error(message)
+static std::uint64_t generateServerId()
 {
+    std::random_device rd;
+    std::mt19937_64 gen(rd());
+    std::uniform_int_distribution<std::uint64_t> dist;
+    return dist(gen);
 }
-// --
 
-cyrex::Server::Server(INetworkPeer* const peer, const Config& config)
+cyrex::Server::Server(const Config& config) : m_config(config), m_serverUniqueId(generateServerId()), m_running(true)
 {
-    if (peer == nullptr)
-    {
-        throw InitFailedError("peer is nullptr");
-    }
+    if (s_instance)
+        throw std::runtime_error("Server already exists");
 
-    this->m_peer = peer;
+    s_instance = this;
 
-    const RakNet::StartupResult startupResult = m_peer->startup({.maxConnections = config.maxUsers, .port = config.port});
+    m_raknet = std::make_unique<cyrex::network::raknet::RaknetHandler>();
+    m_commands = std::make_unique<cyrex::command::CommandManager>(*this);
+    m_commands->registerDefaults();
+}
 
-    // All clear
-    if (startupResult == RakNet::RAKNET_STARTED)
-    {
-        m_peer->setMaximumIncomingConnections(config.maxIncomingConnections);
-        return;
-    }
+cyrex::Server::~Server()
+{
+    // more better cleanup, and we need cleanup function for sessions, etc
+    m_running = false;
+    m_players.clear();
+    s_instance = nullptr;
+}
+
+cyrex::Server& cyrex::Server::getInstance()
+{
+    if (!s_instance)
+        throw std::runtime_error("Server not initialized");
 
-    throw InitFailedError(std::string(magic_enum::enum_name(startupResult)));
+    return *s_instance;
 }
 
-cyrex::Server::~Server()
+std::uint16_t cyrex::Server::getPort() const
 {
-    stop();
+    return m_config.port;
 }
 
-cyrex::Server::Server(Server&& other) noexcept : m_peer{other.m_peer}
+std::uint16_t cyrex::Server::getPortIpv6() const
 {
-    other.m_peer = nullptr;
+    return m_config.portIpv6;
 }
 
-cyrex::Server& cyrex::Server::operator=(Server&& other) noexcept
+std::uint32_t cyrex::Server::getMaxPlayers() const
 {
-    stop();
-    m_peer = other.m_peer;
-    other.m_peer = nullptr;
-    return *this;
+    return m_config.maxPlayers;
 }
 
-void cyrex::Server::run()
+std::uint64_t cyrex::Server::getServerUniqueId() const
 {
-    while (true)
-    {
-        receivePackets();
-        RakSleep(15);
-    }
+    return m_serverUniqueId;
+}
+
+const std::string& cyrex::Server::getServerName() const
+{
+    return m_config.serverName;
+}
+
+const std::string& cyrex::Server::getMotd() const
+{
+    return m_config.motd;
+}
+
+cyrex::mcpe::protocol::types::GameMode cyrex::Server::getDefaultGameMode() const
+{
+    return m_config.defaultGameMode;
+}
+
+void cyrex::Server::setDefaultGameMode(cyrex::mcpe::protocol::types::GameMode mode)
+{
+    m_config.defaultGameMode = mode;
+}
+
+void cyrex::Server::setDefaultGameModeFromString(std::string_view mode)
+{
+    m_config.defaultGameMode = cyrex::mcpe::protocol::types::fromString(mode);
+}
+
+void cyrex::Server::addPlayer(const RakNet::RakNetGUID& guid)
+{
+    if (!hasPlayer(guid))
+        m_players.push_back(guid);
+}
+
+void cyrex::Server::removePlayer(const RakNet::RakNetGUID& guid)
+{
+    auto it = std::remove(m_players.begin(), m_players.end(), guid);
+    m_players.erase(it, m_players.end());
+}
+
+bool cyrex::Server::hasPlayer(const RakNet::RakNetGUID& guid) const
+{
+    return std::find(m_players.begin(), m_players.end(), guid) != m_players.end();
+}
+
+std::size_t cyrex::Server::getPlayerCount() const
+{
+    return m_players.size();
+}
+
+const std::vector<RakNet::RakNetGUID>& cyrex::Server::getAllPlayers() const
+{
+    return m_players;
 }
 
 void cyrex::Server::stop()
 {
-    if (m_peer && m_peer->isActive())
-    {
-        m_peer->shutdown({.blockDuration = 50});
-    }
+    cyrex::Server::~Server();
 }
 
-void cyrex::Server::receivePackets()
+void cyrex::Server::commandLoop()
 {
-    for (RakNet::Packet* packet{}; (packet = m_peer->receive()) != nullptr; m_peer->deallocatePacket(packet))
+    while (m_running)
     {
-        onPacketReceived(packet);
+        std::string line;
+        if (!std::getline(std::cin, line))
+            break;
+
+        m_commands->executeConsole(line);
     }
 }
 
-void cyrex::Server::onPacketReceived(RakNet::Packet* const packet)
+void cyrex::Server::run()
 {
-    if (packet == nullptr)
-    {
-        throw NullPacketException("null packet in onPacketReceived");
-    }
+    std::thread commandThread(&cyrex::Server::commandLoop, this);
 
-    switch (packet->data[0])
+    while (m_running)
     {
-        case ID_NEW_INCOMING_CONNECTION:
-            std::cerr << "A user is connecting...\n";
-            break;
+        m_raknet->poll();
+        std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
-}
+
+    if (commandThread.joinable())
+        commandThread.join();
+}
\ No newline at end of file
diff --git a/src/server.hpp b/src/server.hpp
index 4798aa4..1031247 100644
--- a/src/server.hpp
+++ b/src/server.hpp
@@ -1,10 +1,17 @@
 #pragma once
-#include <stdexcept>
 
-#include <cstdint>
+#include "command/command_manager.hpp"
+#include "network/mcbe/protocol/types/GameMode.hpp"
+#include "network/raknet/raknet_handler.hpp"
+#include "util/server_properties.hpp"
+
+#include <RakNet/RakNetTypes.h>
+#include <atomic>
+#include <memory>
+#include <string>
+#include <vector>
 
-// RakNet
-#include "network_peer.hpp"
+#include <cstdint>
 
 namespace cyrex
 {
@@ -14,50 +21,51 @@ class Server
 public:
     struct Config
     {
-        std::uint16_t port{};
-        std::uint32_t maxUsers{};
-        std::uint16_t maxIncomingConnections{};
-
-        // Default configuration for a typical minecraft bedrock server
-        static constexpr Config makeDefault() noexcept
-        {
-            return {.port = 19132, .maxUsers = 20, .maxIncomingConnections = 5};
-        }
-    };
+        std::uint16_t port;
+        std::uint16_t portIpv6;
+        std::uint32_t maxPlayers;
+        std::string serverName;
+        std::string motd;
+        cyrex::mcpe::protocol::types::GameMode defaultGameMode;
 
-#pragma region Exceptions and Errors
-    struct InitFailedError : std::runtime_error
-    {
-        explicit InitFailedError(const std::string& message);
+        static Config fromProperties(const cyrex::util::ServerProperties& props);
     };
 
-    struct NullPacketException : std::runtime_error
-    {
-        explicit NullPacketException(const std::string& message);
-    };
-#pragma endregion
+    explicit Server(const Config& config);
+    ~Server();
 
-    // Implemented in tests/server.cpp
-    struct Testing;
+    static Server& getInstance();
 
-    // Initializes the server to a usable state
-    // Throws: InitFailedError
-    explicit Server(INetworkPeer* peer, const Config& config);
-    ~Server();
-    Server(Server&& other) noexcept;
-    Server& operator=(Server&& other) noexcept;
-    Server(const Server&) = delete;
-    Server& operator=(const Server&) = delete;
+    std::uint16_t getPort() const;
+    std::uint16_t getPortIpv6() const;
+    std::uint32_t getMaxPlayers() const;
+    std::uint64_t getServerUniqueId() const;
+    const std::string& getServerName() const;
+    const std::string& getMotd() const;
+
+    cyrex::mcpe::protocol::types::GameMode getDefaultGameMode() const;
+    void setDefaultGameMode(cyrex::mcpe::protocol::types::GameMode mode);
+    void setDefaultGameModeFromString(std::string_view mode);
 
+    void addPlayer(const RakNet::RakNetGUID& guid);
+    void removePlayer(const RakNet::RakNetGUID& guid);
+    bool hasPlayer(const RakNet::RakNetGUID& guid) const;
+    std::size_t getPlayerCount() const;
+    const std::vector<RakNet::RakNetGUID>& getAllPlayers() const;
+
+    void stop();
     void run();
 
 private:
-    void stop();
-    void receivePackets();
-    // Throws: NullPacketException if the packet is nullptr
-    void onPacketReceived(RakNet::Packet* packet);
+    void commandLoop();
 
-    INetworkPeer* m_peer;
-};
+    static Server* s_instance;
 
-} // namespace cyrex
+    Config m_config;
+    std::unique_ptr<cyrex::network::raknet::RaknetHandler> m_raknet;
+    std::vector<RakNet::RakNetGUID> m_players;
+    std::uint64_t m_serverUniqueId;
+    std::atomic<bool> m_running;
+    std::unique_ptr<cyrex::command::CommandManager> m_commands;
+};
+} // namespace cyrex
\ No newline at end of file
diff --git a/src/util/performance.cpp b/src/util/performance.cpp
new file mode 100644
index 0000000..18d9a14
--- /dev/null
+++ b/src/util/performance.cpp
@@ -0,0 +1,41 @@
+#include "performance.hpp"
+
+#include "util/textformat.hpp"
+
+#include <chrono>
+#include <sstream>
+#include <thread>
+
+namespace util::performance
+{
+std::string getReport()
+{
+    using namespace util::textformat;
+
+    static auto startTime = std::chrono::steady_clock::now();
+    auto now = std::chrono::steady_clock::now();
+
+    auto uptimeSeconds = std::chrono::duration_cast<std::chrono::seconds>(now - startTime).count();
+
+    auto uptimeMinutes = uptimeSeconds / 60;
+    auto uptimeHours = uptimeMinutes / 60;
+    uptimeSeconds %= 60;
+    uptimeMinutes %= 60;
+
+    std::ostringstream out;
+
+    out << bedrock(Color::AQUA) << bedrock(Style::BOLD) << "=== Server Performance ===" << bedrock(Style::RESET) << "\n";
+
+    out << bedrock(Color::YELLOW) << "Uptime: " << bedrock(Color::WHITE) << uptimeHours << "h " << uptimeMinutes << "m "
+        << uptimeSeconds << "s\n";
+
+    out << bedrock(Color::YELLOW) << "CPU Threads: " << bedrock(Color::WHITE) << std::thread::hardware_concurrency()
+        << "\n";
+
+    out << bedrock(Color::YELLOW) << "Clock: " << bedrock(Color::GRAY) << "steady_clock\n";
+
+    out << bedrock(Color::DARK_GRAY) << "==========================" << bedrock(Style::RESET);
+
+    return out.str();
+}
+} // namespace util::performance
diff --git a/src/util/performance.hpp b/src/util/performance.hpp
new file mode 100644
index 0000000..d5b797a
--- /dev/null
+++ b/src/util/performance.hpp
@@ -0,0 +1,8 @@
+#pragma once
+
+#include <string>
+
+namespace util::performance
+{
+std::string getReport();
+}
diff --git a/src/util/server_properties.cpp b/src/util/server_properties.cpp
new file mode 100644
index 0000000..ab30da2
--- /dev/null
+++ b/src/util/server_properties.cpp
@@ -0,0 +1,64 @@
+#include "util/server_properties.hpp"
+
+#include <filesystem>
+#include <fstream>
+#include <sstream>
+#include <unordered_map>
+
+static ServerProperties defaults()
+{
+    return {19134, 19135, 100, "CyrexMC", "Cyrex MCBE Software", mcpe::protocol::types::GameMode::SURVIVAL};
+}
+
+static void writeDefaults(const std::string& path, const ServerProperties& cfg)
+{
+    std::ofstream out(path);
+    out << "server-port=" << cfg.port << "\n";
+    out << "server-portv6=" << cfg.portIpv6 << "\n";
+    out << "max-players=" << cfg.maxPlayers << "\n";
+    out << "server-name=" << cfg.serverName << "\n";
+    out << "motd=" << cfg.motd << "\n";
+    out << "gamemode=" << mcpe::protocol::types::toString(cfg.defaultGameMode) << "\n";
+}
+
+ServerProperties ServerProperties::load(const std::string& path)
+{
+    if (!std::filesystem::exists(path))
+    {
+        auto def = defaults();
+        writeDefaults(path, def);
+        return def;
+    }
+
+    auto cfg = defaults();
+    std::ifstream in(path);
+    std::string line;
+
+    while (std::getline(in, line))
+    {
+        if (line.empty() || line[0] == '#')
+            continue;
+
+        auto pos = line.find('=');
+        if (pos == std::string::npos)
+            continue;
+
+        std::string key = line.substr(0, pos);
+        std::string val = line.substr(pos + 1);
+
+        if (key == "server-port")
+            cfg.port = static_cast<std::uint16_t>(std::stoi(val));
+        else if (key == "server-portv6")
+            cfg.portIpv6 = static_cast<std::uint16_t>(std::stoi(val));
+        else if (key == "max-players")
+            cfg.maxPlayers = static_cast<std::uint32_t>(std::stoi(val));
+        else if (key == "server-name")
+            cfg.serverName = val;
+        else if (key == "motd")
+            cfg.motd = val;
+        else if (key == "gamemode")
+            cfg.defaultGameMode = mcpe::protocol::types::fromString(val);
+    }
+
+    return cfg;
+}
diff --git a/src/util/server_properties.hpp b/src/util/server_properties.hpp
new file mode 100644
index 0000000..3a5243a
--- /dev/null
+++ b/src/util/server_properties.hpp
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "network/mcbe/protocol/types/GameMode.hpp"
+
+#include <string>
+
+#include <cstdint>
+
+struct ServerProperties
+{
+    std::uint16_t port;
+    std::uint16_t portIpv6;
+    std::uint32_t maxPlayers;
+    std::string serverName;
+    std::string motd;
+    mcpe::protocol::types::GameMode defaultGameMode;
+
+    static ServerProperties load(const std::string& path);
+};
diff --git a/src/util/textformat.hpp b/src/util/textformat.hpp
new file mode 100644
index 0000000..bc7573a
--- /dev/null
+++ b/src/util/textformat.hpp
@@ -0,0 +1,161 @@
+#pragma once
+
+#include <string>
+#include <string_view>
+#include <unordered_map>
+
+#include <chrono>
+#include <iomanip>
+#include <sstream>
+
+namespace util::textformat
+{
+// should make sure this is proper
+inline constexpr char CODE = '\xA7';
+
+enum class Color : char
+{
+    BLACK = '0',
+    DARK_BLUE = '1',
+    DARK_GREEN = '2',
+    DARK_AQUA = '3',
+    DARK_RED = '4',
+    DARK_PURPLE = '5',
+    GOLD = '6',
+    GRAY = '7',
+    DARK_GRAY = '8',
+    BLUE = '9',
+    GREEN = 'a',
+    AQUA = 'b',
+    RED = 'c',
+    LIGHT_PURPLE = 'd',
+    YELLOW = 'e',
+    WHITE = 'f',
+
+    MINECOIN_GOLD = 'g',
+    QUARTZ = 'h',
+    IRON = 'i',
+    NETHERITE = 'j',
+    REDSTONE = 'm',
+    COPPER = 'n',
+    GOLD_MATERIAL = 'p',
+    EMERALD = 'q',
+    DIAMOND = 's',
+    LAPIS = 't',
+    AMETHYST = 'u',
+    RESIN = 'v'
+};
+
+enum class Style : char
+{
+    OBFUSCATED = 'k',
+    BOLD = 'l',
+    ITALIC = 'o',
+    RESET = 'r'
+};
+
+inline std::string bedrock(Color c)
+{
+    return std::string{CODE, static_cast<char>(c)};
+}
+
+inline std::string bedrock(Style s)
+{
+    return std::string{CODE, static_cast<char>(s)};
+}
+
+inline std::string color(Color c, std::string_view text)
+{
+    return bedrock(c) + std::string(text) + bedrock(Style::RESET);
+}
+
+inline std::string style(Style s, std::string_view text)
+{
+    return bedrock(s) + std::string(text) + bedrock(Style::RESET);
+}
+
+inline std::string strip(std::string_view text)
+{
+    std::string out;
+    for (size_t i = 0; i < text.size(); ++i)
+    {
+        if (text[i] == CODE && i + 1 < text.size())
+        {
+            ++i;
+            continue;
+        }
+        out.push_back(text[i]);
+    }
+    return out;
+}
+
+// Put this instead in an utility like time, temporary
+inline std::string currentTime()
+{
+    using namespace std::chrono;
+
+    auto now = system_clock::now();
+    auto tt = system_clock::to_time_t(now);
+
+    std::tm tm{};
+#ifdef _WIN32
+    localtime_s(&tm, &tt);
+#else
+    localtime_r(&tt, &tm);
+#endif
+
+    std::ostringstream ss;
+    ss << std::put_time(&tm, "%H:%M:%S");
+    return ss.str();
+}
+
+
+inline std::string renderConsole(std::string_view text, bool includeTime)
+{
+    static const std::unordered_map<char, std::string>
+        ansi{{'0', "\033[30m"},
+             {'1', "\033[34m"},
+             {'2', "\033[32m"},
+             {'3', "\033[36m"},
+             {'4', "\033[31m"},
+             {'5', "\033[35m"},
+             {'6', "\033[33m"},
+             {'7', "\033[37m"},
+             {'8', "\033[90m"},
+             {'9', "\033[94m"},
+             {'a', "\033[92m"},
+             {'b', "\033[96m"},
+             {'c', "\033[91m"},
+             {'d', "\033[95m"},
+             {'e', "\033[93m"},
+             {'f', "\033[97m"},
+             {'l', "\033[1m"},
+             {'o', "\033[3m"},
+             {'r', "\033[0m"}};
+
+    std::string out;
+
+    if (includeTime)
+    {
+        out += "\033[90m[";
+        out += currentTime();
+        out += "] \033[0m";
+    }
+
+    for (size_t i = 0; i < text.size(); ++i)
+    {
+        if (text[i] == CODE && i + 1 < text.size())
+        {
+            auto it = ansi.find(text[i + 1]);
+            if (it != ansi.end())
+                out += it->second;
+            ++i;
+            continue;
+        }
+        out.push_back(text[i]);
+    }
+
+    out += "\033[0m";
+    return out;
+}
+} // namespace util::textformat
